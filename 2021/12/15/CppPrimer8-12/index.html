

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;dark&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Hinageshi">
  <meta name="keywords" content="">
  
  <title>笔记 C++ Primer 第八章~第十二章 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":25,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["_slim",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":17057737,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Hinageshi的駄菓子屋</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archive
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/backGround.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="笔记 C++ Primer 第八章~第十二章">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-15 10:55" pubdate>
        December 15, 2021
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      73
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">笔记 C++ Primer 第八章~第十二章</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：May 20, 2022
                
              </p>
            
            <div class="markdown-body">
              <h1 id="序言"><a class="markdownIt-Anchor" href="#序言"></a> 序言</h1>
<p>  《C++ Primer 5th Edition》标准库部分的读书笔记。</p>
<h1 id="第八章-io-库"><a class="markdownIt-Anchor" href="#第八章-io-库"></a> 第八章 IO 库</h1>
<h2 id="81-io-类"><a class="markdownIt-Anchor" href="#81-io-类"></a> 8.1 IO 类</h2>
<h3 id="811-io-对象无拷贝或赋值"><a class="markdownIt-Anchor" href="#811-io-对象无拷贝或赋值"></a> 8.1.1 IO 对象无拷贝或赋值</h3>
<p>进 IO 操作的函数通常以引用方式传递和返回流。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是 const 的。</p>
<h3 id="812-条件状态"><a class="markdownIt-Anchor" href="#812-条件状态"></a> 8.1.2 条件状态</h3>
<p>如果我们输入一个非期望的数据类型或一个文件结束标识，cin 会进入错误状态。<br />
一个流一旦发生错误，其上后续 IO 操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。</p>
<h3 id="813-管理输出缓冲"><a class="markdownIt-Anchor" href="#813-管理输出缓冲"></a> 8.1.3 管理输出缓冲</h3>
<p>读 cin 或写 cerr 都会导致 cout 的缓冲区被刷新。</p>
<p><strong>unitbf</strong><br />
unitbuf 操纵符告诉流在接下来的每次写操作之后都进行一次 flush 操作。而 nounitbuf 操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">cout &lt;&lt; unitbuf;<br>cout &lt;&lt; nounitbuf;<br></code></pre></div></td></tr></table></figure>
<p><strong>关联输入和输出流</strong><br />
当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。<br />
标准库将 cout 和 cin 关联在一起，<br />
tie 有两个重载的版本：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie 的第二个版本接受一个指向 ostream 的指针，将自己关联到此 ostream。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">in.<span class="hljs-built_in">tie</span>(&amp;out);<br><span class="hljs-comment">// old_tie 指向当前关联到 in 的流，in 不再与其他流关联。</span><br>ostream *old_out = in.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>in.<span class="hljs-built_in">tie</span>(&amp;new_out);<br>in.<span class="hljs-built_in">tie</span>(old_out);<br></code></pre></div></td></tr></table></figure>
<h2 id="82-文件输入输出"><a class="markdownIt-Anchor" href="#82-文件输入输出"></a> 8.2 文件输入输出</h2>
<p>ifstream 从一个给定文件读取数据，ofstream 向一个给定文件写入数据，以及 fstream 可以读写给定文件。</p>
<h3 id="821-使用文件流对象"><a class="markdownIt-Anchor" href="#821-使用文件流对象"></a> 8.2.1 使用文件流对象</h3>
<p>创建文件流对象时，我们可以提供文件名。如果提供了一个文件名，则 open 会自动被调用。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。当一个 fstream 对象被销毁时，close 会自动被调用。</p>
<h3 id="822-文件模式"><a class="markdownIt-Anchor" href="#822-文件模式"></a> 8.2.2 文件模式</h3>
<p>in：以读方式打开；out：以写方式打开；app：每次写操作前均定位到文件末尾；ate：打开文件后立即定位到文件末尾；trunc：截断文件；binary：以二进制方式进 IO；<br />
在 app 模式下，即使没有显式指定 out 模式，文件也总是以输出方式被打开。<br />
即使我们没有指定 trun ，以 out 模式打幵的文件也会被截断。<br />
与 ifstream 关联的文件默认以 in 模式打幵；与 ofstream 关联的文件默认以 out 模式打开；与 fstream 关联的文件默认以 in 和 out 模式打幵。<br />
默认情况下，当我们打开一个 ofstream 时，文件的内容会被丢弃。每当打开文件时，都可以改变其文件模式。</p>
<h2 id="83-string-流"><a class="markdownIt-Anchor" href="#83-string-流"></a> 8.3 string 流</h2>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">sstream <span class="hljs-title">strm</span><span class="hljs-params">(s)</span></span>; <span class="hljs-comment">// strm 保存 string s 的一个拷贝。</span><br>strm.<span class="hljs-built_in">str</span>(); <span class="hljs-comment">// 返回 strm 保存的 string 拷贝。</span><br>strm.<span class="hljs-built_in">str</span>(s); <span class="hljs-comment">// 将 string s 拷贝到 strm 中，返回 void。</span><br></code></pre></div></td></tr></table></figure>
<h1 id="第九章-顺序容器"><a class="markdownIt-Anchor" href="#第九章-顺序容器"></a> 第九章 顺序容器</h1>
<h2 id="91-顺序容器概述"><a class="markdownIt-Anchor" href="#91-顺序容器概述"></a> 9.1 顺序容器概述</h2>
<p><strong>vector</strong>：可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。<br />
<strong>deque</strong>：双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。<br />
<strong>list</strong>：双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除 操作速度都很快。<br />
<strong>forward_list</strong>：单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。<br />
<strong>array</strong>：固定大小数组。支持快速随机访问。不能添加或删除元素。<br />
<strong>string</strong>：与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。</p>
<p><strong>确定使用哪种顺序容器</strong></p>
<ul>
<li>除非你有很好的理由选择其他容器，否则应使用 vector。</li>
<li>如果你的程序有很多小的元素，且空间的额外开销很重要，则不耍使用 list 或 forward_list。</li>
<li>如果程序要求随机访问兀素，应使用 vector 或 deque。</li>
<li>如果程序要求在容器的中间插入或删除元素，应使用 list 或 forward_list。</li>
<li>如果程序需要在头尾位置插入或刪除元素，但不会在中间位置进行插入或删除操作，则使用 deque。</li>
</ul>
<h3 id="924-容器定义和初始化"><a class="markdownIt-Anchor" href="#924-容器定义和初始化"></a> 9.2.4 容器定义和初始化</h3>
<p><strong>标准库 array 具有固定大小</strong><br />
当定义一个 array 时，除了指定元素类型，还要指定容器大小。<br />
一个默认构造的 array 是非空的，它包含了与其大小一样多的元素。这些元素都被默认初始化。<br />
如果初始值列表中的初始值数目小于 array 的大小，则它们被用来初始化 array 中靠前的元素，所有剩余元素都会进行值初始化。<br />
此外，array 还要求初始值元素类型和大小也都一样，因为大小是 array 类型的一部分。</p>
<h3 id="925-赋值和-swap"><a class="markdownIt-Anchor" href="#925-赋值和-swap"></a> 9.2.5 赋值和 swap</h3>
<p>array 类型不支持 assign, 也不允许用花括号包围的值列表进行赋值。<br />
賦值相关运算会导致指向左边容器内部的迭代器、引用和指针失效而 swap 操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效。</p>
<p><strong>使用 assign (仅顺序容器）</strong><br />
assign 允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。用参数所指定的元素（的拷贝）替换左边容器中Й所有元素。<br />
传递给 assign 的迭代器不能指向调用 assign 的容器。</p>
<p><strong>使用 swap</strong><br />
swap 不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。<br />
元素不会被移动意味着，除 string 外，指向容器的迭代器、引用和指针在 swap 操作之后都不会失效。它们仍指向 swap 操作之前所指向的那些元素。但是，在 swap 之后，这些元素已经属于不同的容器了。<br />
与其他容器不同，swap 两个 array 会真正交换它们的元素。因此，交换两个 array 所需的时间与 array 中元素的数目成正比。</p>
<h3 id="927-关系运算符"><a class="markdownIt-Anchor" href="#927-关系运算符"></a> 9.2.7 关系运算符</h3>
<p>关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。比较两个容器实际上是逐元素使用元素的关系运算符完成比较。<br />
如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算。</p>
<h2 id="93-顺序容器操作"><a class="markdownIt-Anchor" href="#93-顺序容器操作"></a> 9.3 顺序容器操作</h2>
<h3 id="931-向顺序容器添加元素"><a class="markdownIt-Anchor" href="#931-向顺序容器添加元素"></a> 9.3.1 向顺序容器添加元素</h3>
<p><strong>使用 emplace 操作</strong><br />
当调用 push 或 insert 成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。<br />
而当我们调用一个 emplace 成员函数时，则是将参数传递给元素类型的构造函数。emplace 成员使用这些参数在容器管理的内存空间中直接构造元素。</p>
<h3 id="932-访问元素"><a class="markdownIt-Anchor" href="#932-访问元素"></a> 9.3.2 访问元素</h3>
<p>front() 返回首元素的引用，back() 返回尾元素的引用。c[n] 与 <a target="_blank" rel="noopener" href="http://a.at">a.at</a>(n) 在 n 未越界时效果相同，越界时 at() 抛出 out_of_range 异常。</p>
<h3 id="935-改变容器大小"><a class="markdownIt-Anchor" href="#935-改变容器大小"></a> 9.3.5 改变容器大小</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">list&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ilist</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">42</span>)</span></span>;<br>ilist.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>, <span class="hljs-number">-1</span>); <span class="hljs-comment">// 将 5 个 -1 添加到 ilist 的末尾。</span><br>ilist.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 从 ilist 的末尾删除 10 个元素。</span><br></code></pre></div></td></tr></table></figure>
<h3 id="936-容器操作可能使迭代器失效"><a class="markdownIt-Anchor" href="#936-容器操作可能使迭代器失效"></a> 9.3.6 容器操作可能使迭代器失效</h3>
<p>当我们删除元素时，尾后迭代器总是会失效。保证每次改变谷器的操作之后都正确地重新定位迭代器。<br />
不能在循环之前保存 end 返回的迭代器，通常 end() 操作都很快。</p>
<h2 id="94-vector-对象是如何增长的"><a class="markdownIt-Anchor" href="#94-vector-对象是如何增长的"></a> 9.4 vector 对象是如何增长的</h2>
<p>没有空间容纳新元素，因为元素必须连续存储，容器必须分配新的内存空间来保存己有元素和新元素，将已有元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空间。<br />
vector 和 string 的实现通常会分配比新的空间需求更大的内存空间，容器预留这些空间作为备用。<br />
补充：<a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_a2a6dd380102w73e.html">push_back 的时间复杂度为什么是 o(1)</a></p>
<p><strong>管理容量的成员函数</strong><br />
c.shrink_to_fit()：请求将 capacity() 减少为与 size() 相同d 大小，标准库并不保证一定能退还内存。<br />
c.capacity()：不重新分配内存空间的话，容器可以保存多少兀素。<br />
c.reserve(n)：分配至少能容纳 n 个元素的内存空间。<br />
reserve 并不改变容器中元素的数量，它仅影响 vector 預先分配多大的内存空间。只有当需要的内存空间超过当前容量时，reserve 调用才会改变 vector 的容量，否则什么也不做，所以说调用 reserve 永远也不会减少容器占用的内存空间。</p>
<h2 id="95-额外的-string-操作"><a class="markdownIt-Anchor" href="#95-额外的-string-操作"></a> 9.5 额外的 string 操作</h2>
<h3 id="953-string-搜索操作"><a class="markdownIt-Anchor" href="#953-string-搜索操作"></a> 9.5.3 string 搜索操作</h3>
<p>如果搜索失败，则返回一个名为 stringr::npos 的 static 成员。<br />
string 搜索函数返回 string::size_type 值，该类型是一个 unsigned 类型。因此，用一个 int 或其他带符号类型来保存这些函数的返回值不是一个好主意。</p>
<h1 id="第十章-泛型算法"><a class="markdownIt-Anchor" href="#第十章-泛型算法"></a> 第十章 泛型算法</h1>
<h2 id="102-初始泛型算法"><a class="markdownIt-Anchor" href="#102-初始泛型算法"></a> 10.2 初始泛型算法</h2>
<h3 id="1022-写容器元素的算法"><a class="markdownIt-Anchor" href="#1022-写容器元素的算法"></a> 10.2.2 写容器元素的算法</h3>
<p><strong>介绍 back_inserter</strong><br />
back_inserter 接受一个指向容器的引用，当我们通过此迭代器赋值时，赋值运算符会调用 push_back 将一个具有给定值的元素添加到容器中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt; vec; <span class="hljs-comment">// 空向量</span><br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">back_inserter</span>(vec); <span class="hljs-comment">// 通过它賦值会将元素添加到 vec 中</span><br>it = <span class="hljs-number">42</span>; <span class="hljs-comment">// vec 中现在有一个元素，值为 42</span><br></code></pre></div></td></tr></table></figure>
<h2 id="103-定制操作"><a class="markdownIt-Anchor" href="#103-定制操作"></a> 10.3 定制操作</h2>
<h3 id="向算法传递函数"><a class="markdownIt-Anchor" href="#向算法传递函数"></a> 向算法传递函数</h3>
<p><strong>谓词</strong><br />
谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为一元谓词和二元谓词。</p>
<h3 id="1032-lambda-表达式"><a class="markdownIt-Anchor" href="#1032-lambda-表达式"></a> 10.3.2 lambda 表达式</h3>
<p><strong>介绍lambda</strong><br />
可以将其理解为一个未命名的内联函数。lambda可能定义在函数内部。lambda 必须使用尾置返回。一个lambda表达式具有如下形式：<br />
[capture list] (parameter list) -&gt; return type { function body }<br />
如果 lambda 的函数体包含任何单一 return 语句之外的内容，且未指定返回类型，则返回 void。</p>
<p><strong>向lambda传递参数</strong><br />
lambda 不能有默认参数。一个 lambda 通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引 lambda 在其内部包含访问局部变量所需的信息。<br />
捕获列表只用于局部非 static 变量，lambda 可以直接使用局部 static 变量和在它所在函数之外声明的名字。</p>
<h3 id="1033-lambda-捕获的返回"><a class="markdownIt-Anchor" href="#1033-lambda-捕获的返回"></a> 10.3.3 lambda 捕获的返回</h3>
<p>当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象。<br />
值捕获则是在定义之时进行捕获，而引用捕获在调用时进行捕获。</p>
<p><strong>值捕获</strong><br />
采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝，随后对其修改不会影响到 lambda 内对应的值。</p>
<p><strong>引用捕获</strong><br />
采用引用方式捕获一个变量，就必须确保被引用的对象在 lambda 执行的时候是存在的。</p>
<p><strong>隐式捕获</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">[=](<span class="hljs-keyword">const</span> string &amp;s)<br>&#123; <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span> () &gt;= sz; &#125; <span class="hljs-comment">// sz 未隐式的值捕获</span><br></code></pre></div></td></tr></table></figure>
<p>如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// os隐式捕获，引用捕获方式；c 显式捕获，值捕获方式</span><br>[&amp;, c](<span class="hljs-keyword">const</span> string &amp;s)	&#123; os &lt;&lt; s &lt;&lt; c; &#125;<br><span class="hljs-comment">// os显式捕获，引用捕获方式；c隐式捕获，值捕获方式</span><br>[=, &amp;os](<span class="hljs-keyword">const</span> string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;<br></code></pre></div></td></tr></table></figure>
<p>当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个 &amp; 或 =。此符号指定了默认捕获方式为引用或值，显式捕获的变量必须使用与隐式捕获不同的方式。</p>
<p><strong>可变 lambda</strong><br />
如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字 mutable。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">void</span> fсп() &#123;<br><span class="hljs-keyword">int</span> vl = <span class="hljs-number">42</span>; <span class="hljs-comment">// 局部变量</span><br><span class="hljs-comment">// f 可以改变它所捕获的变量的值</span><br><span class="hljs-keyword">auto</span> f = [vl] () <span class="hljs-keyword">mutable</span> &#123; <span class="hljs-keyword">return</span> ++vl; &#125;;<br>vl = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// j 为 43</span><br></code></pre></div></td></tr></table></figure>
<h3 id="1034-参数绑定"><a class="markdownIt-Anchor" href="#1034-参数绑定"></a> 10.3.4 参数绑定</h3>
<p><strong>标准库 bind 函数</strong><br />
bind 接受一个可调用对象，生成一个新的可调用对 象来“适应”原对象的参数列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> newCallable = <span class="hljs-built_in">bind</span> (callable, arg_list);<br></code></pre></div></td></tr></table></figure>
<p>当我们调用 newCallable 时 newCallable 会调用 callable，并传递给它中的参数。<br />
arg_list 参数可能包含形如 _n 的名字。这些参数是“占位符”，其本身的位置代表其在原函数形参列表中的位置，其数字代表其在新函数形参列表中的位置。<br />
名字 _n 都定义在一个名为 placeholders 的命名空间中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> newFun = <span class="hljs-built_in">bind</span>(oldFun, a, b, _2, c, _1);<br></code></pre></div></td></tr></table></figure>
<p>这个 bind 调用会将 <code>newFun(_1, _2);</code> 映射为 <code>oldFun(a, b, _2, с, _1);</code></p>
<p><strong>绑定引用参数</strong><br />
如果我们希望传递给 bind 一个对象而又不拷贝它，就必须使用标准库 ref 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 我们无法拷贝 ostream</span><br>for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind</span>(print, <span class="hljs-built_in">ref</span>(os), _1, <span class="hljs-string">&#x27; &#x27;</span>));<br></code></pre></div></td></tr></table></figure>
<p>函数 ref 返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个 cref 函数，生成一个保存 const 引用的类。</p>
<h1 id="第十一章-关联容器"><a class="markdownIt-Anchor" href="#第十一章-关联容器"></a> 第十一章 关联容器</h1>
<p>允许重复关键字的容器的名字中都包含单词 multi，不保持关键字按顺序存储的容器的名字都以单词 unordered 开头。</p>
<h2 id="111-使用关联容器"><a class="markdownIt-Anchor" href="#111-使用关联容器"></a> 11.1 使用关联容器</h2>
<p>如果下标还未在 map 中，下标运算符会创建一个新元素，其关键字为下标，值为值初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(target) == set.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-comment">// set 中不存在 target</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="112-关联容器概述"><a class="markdownIt-Anchor" href="#112-关联容器概述"></a> 11.2 关联容器概述</h2>
<h3 id="1122-关键字类型的要求"><a class="markdownIt-Anchor" href="#1122-关键字类型的要求"></a> 11.2.2 关键字类型的要求</h3>
<p>对于有序容器 map、multimap、set 以及 multiset，关键字类型必须定义元素比较的方法</p>
<h3 id="1123-pair-类型"><a class="markdownIt-Anchor" href="#1123-pair-类型"></a> 11.2.3 pair 类型</h3>
<p>一个 pair 保存两个 public 数据成员， 两个成员分别命名为 first 和 second。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">make_pair</span>(v1, v2); <span class="hljs-comment">// pair 的类型由 v1 v2 推断出来。</span><br></code></pre></div></td></tr></table></figure>
<h2 id="113-关联容器的操作"><a class="markdownIt-Anchor" href="#113-关联容器的操作"></a> 11.3 关联容器的操作</h2>
<p>key_type：此容器类型的关键字类型。<br />
mapped_type：每个关键字关联的类型，只适用于map。<br />
value_type：对于 set，与 key_type 相同；对于 map，为 <code>pair&lt;const key_type, mapped_type&gt;</code><br />
关键字是 const 的。</p>
<h3 id="1132-添加元素"><a class="markdownIt-Anchor" href="#1132-添加元素"></a> 11.3.2 添加元素</h3>
<p>插入一个已存在的元素对容器没有任何影响。</p>
<p><strong>检测 insert 的返回值</strong><br />
添加单一元素的 insert 和 emplace 版本返冋一个 pair，first 成员是一个迭代器，指向具有给定关键字的元素；second 成员是一个 bool 值，指出元素是插入成功还是已经存在于容器中。</p>
<h3 id="1134-map-的下标操作"><a class="markdownIt-Anchor" href="#1134-map-的下标操作"></a> 11.3.4 map 的下标操作</h3>
<p>set 类型不支持下标，也不能对一个 multimap 或一个 unordered_multimap 进行下标操作。<br />
如果关键字并不在 map 中，会为它创建一个元素并插入到 map 中，关联值将进行值初始化。如果不希望产生新的插入，可以使用 at()。<br />
当对一个 map 进行下标操作时，会获得一个 mapped_type 对象；但当解引用一个 map 迭代器时，会得到一个 value_type 对象。</p>
<h3 id="1135-访问元素"><a class="markdownIt-Anchor" href="#1135-访问元素"></a> 11.3.5 访问元素</h3>
<p>c.lower_bound(k)：返回一个迭代器，指向第一个关键字不小于к的元素。<br />
с.upper_bound(k)：返回一个迭代器，指向第一个关键字大于к的元素。<br />
с.equal_range(k)：返回一个迭代器 pair，表示关键字等于 K 的元素的范围。若不存在，pair 的两个成员均等于 c.end()。<br />
若关键字未匹配，他们都返回一个迭代器，指向不影响排序的关键字插入位置。</p>
<p><strong>在 multimap 或 multiset 中查找元素</strong><br />
如果一个 multimap 或 multiset 中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。</p>
<h2 id="在容器中使用自定义的类"><a class="markdownIt-Anchor" href="#在容器中使用自定义的类"></a> 在容器中使用自定义的类</h2>
<p>如果要在 map/set 中使用自定义的类，需要提供判断 &lt; 的方法。<br />
如果要在 unordered_map/unordered_set 中使用自定义的类，需要提供计算哈希值的方法，以及判断 == 的方法。</p>
<ul>
<li>使用函数指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Line</span>&#123;</span><span class="hljs-comment">/* 成员与构造函数 */</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">m_hash</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> Line &amp;l)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> l.k * <span class="hljs-number">100</span> + l.b;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">m_equal</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> Line &amp;l1, <span class="hljs-keyword">const</span> Line &amp;l2)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> l1.k == l2.k &amp;&amp; l1.b == l2.b;<br>&#125;;<br><br><span class="hljs-comment">// 参数代表了桶的大小、哈希函数指针、相等性判断运算符函数指针</span><br><span class="hljs-function">unordered_set&lt;Line, <span class="hljs-title">decltype</span><span class="hljs-params">(m_hash)</span>*, <span class="hljs-title">decltype</span><span class="hljs-params">(m_equal)</span>*&gt; <span class="hljs-title">h_set</span><span class="hljs-params">(<span class="hljs-number">42</span>, m_hash, m_equal)</span></span>;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>如果我们的类重载了 == 运算符，则可以只重载哈希函数。<br />
并且，我们可以通过重载函数调用运算符的方式提供一个函数对象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Line</span> &#123;</span><br>    <span class="hljs-comment">// 成员与构造函数</span><br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-keyword">const</span> Line &amp;l) <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">return</span>  k == l.k &amp;&amp; b == l.b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LineHash</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> Line &amp;l)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span>  l.k * <span class="hljs-number">100</span> + l.b;<br>    &#125;<br>&#125;;<br><br>unordered_set &lt;Line, LineHash&gt; h_set;<br>unordered_map &lt;Line, string, LineHash&gt; h_map;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>最后，在 C++20 中似乎可以用 lambda 代替这个函数对象。</li>
</ul>
<blockquote>
<p>C++11 到 C++17 里，lambda 表达式的复制运算符被删除了，这导致 lambda 表达式无法复制构造，不满足哈希函数所需的条件（是函数对象，可复制构造，可析构，调用时对相同对象返回相同哈希）。<br />
C++20 里据说无捕获的 lambda 表达式可以复制构造了。理论上这应该解决了 lambda 表达式不能做哈希的缺陷。<br />
<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/469655331">知乎</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Line</span>&#123;</span><span class="hljs-comment">/* 成员与构造函数 */</span>&#125;;<br><br><span class="hljs-keyword">auto</span> m_hash = [](<span class="hljs-keyword">const</span> Line &amp;l) &#123;<br>	<span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword">size_t</span>)(l.k * <span class="hljs-number">100</span> + l.b);<br>&#125;;<br><span class="hljs-keyword">auto</span> m_equal = [](<span class="hljs-keyword">const</span> Line &amp;l1, <span class="hljs-keyword">const</span> Line &amp;l2) &#123;<br>	<span class="hljs-keyword">return</span> l1.k == l2.k &amp;&amp; l1.b == l2.b;<br>&#125;;<br><br>unordered_set&lt;Line, <span class="hljs-keyword">decltype</span>(m_hash), <span class="hljs-keyword">decltype</span>(m_equal)&gt; h_set;<br><span class="hljs-comment">// 或者写成</span><br><span class="hljs-function">unordered_set&lt;Line, <span class="hljs-title">decltype</span><span class="hljs-params">(m_hash)</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(m_equal)</span>&gt; <span class="hljs-title">h_set</span><span class="hljs-params">(<span class="hljs-number">42</span>, m_hash, m_equal)</span></span>;<br></code></pre></div></td></tr></table></figure>
<h1 id="第十二章-动态内存"><a class="markdownIt-Anchor" href="#第十二章-动态内存"></a> 第十二章 动态内存</h1>
<p>分配在静态或栈内存中的对象由编译器自动创建和销毁。每个程序还拥有一个内存池，这部分内存被称作自由空间或堆。程序用堆来存储动态分配的对象。</p>
<h2 id="121-动态内存与智能指针"><a class="markdownIt-Anchor" href="#121-动态内存与智能指针"></a> 12.1 动态内存与智能指针</h2>
<h3 id="1211-shared_ptr-类"><a class="markdownIt-Anchor" href="#1211-shared_ptr-类"></a> 12.1.1 shared_ptr 类</h3>
<p>最安全的分配和使用动态内存的方法是调用一个名为 make_shared&lt;&gt;() 的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象 shared_ptr。<br />
每个 shared_ptr 都有一个关联的计数器，通常称其为引用计数。一旦一个 shared_ptr 的计数器变为 0，它就会自动释放自己所管理的对象。但只要有其他 shared_ptr 也指向这块内存，它就不会被释放掉。<br />
补充：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a704fef4809c">shared_ptr 导致的循环引用及其解决方法</a></p>
<h3 id="1212-直接管理内存"><a class="markdownIt-Anchor" href="#1212-直接管理内存"></a> 12.1.2 直接管理内存</h3>
<p><strong>使用 new 动态分配和初始化对象</strong><br />
new 无法为其分配的对象命名，而是返回一个指向该对象的指针。动态分配的对象是默认初始化的，而类类型对象将用默认构造函数进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>; <span class="hljs-comment">// 默认初始化</span><br><span class="hljs-keyword">int</span> *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(); <span class="hljs-comment">// 值初始化</span><br></code></pre></div></td></tr></table></figure>
<p>只有当括号中仅有单一初始化器时才可以使用 auto 推断 new 的返回值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p2 = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (nothrow) <span class="hljs-keyword">int</span>; <span class="hljs-comment">//如果分配失败，new 返回一个空才旨针，不抛出异常</span><br></code></pre></div></td></tr></table></figure>
<h3 id="1213-shared_ptr-和-new-结合使用"><a class="markdownIt-Anchor" href="#1213-shared_ptr-和-new-结合使用"></a> 12.1.3 shared_ptr 和 new 结合使用</h3>
<p>不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">42</span>); <span class="hljs-comment">//错误：必须使用直接初始化形式</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p2</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>; <span class="hljs-comment">// 正确：使用了直接初始化形式</span><br></code></pre></div></td></tr></table></figure>
<p>一个临时的 shared_ptr 指向的内存会立刻被释放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>; <span class="hljs-comment">//危险：x 是一个普通指针，不是一个智能指针</span><br><span class="hljs-built_in">process</span> (x); <span class="hljs-comment">// 错误：不能将 int* 转换为一个 shared_ptr&lt;int&gt;</span><br><span class="hljs-built_in">process</span> (shared_ptr&lt;<span class="hljs-keyword">int</span>&gt;(x)); <span class="hljs-comment">// 合法的，但内存会被释放</span><br><span class="hljs-keyword">int</span> j = *x; <span class="hljs-comment">// 未定义的：X 是一个空悬指针</span><br></code></pre></div></td></tr></table></figure>
<p>使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁。<br />
也不要使用 get 初始化另一个智能指针或为智能指针赋值，因为另一个智能指针会做额外的 delete。<br />
而且使用 get 返回的指针的代码不能 delete 此指针。</p>
<h3 id="1214-智能指针的异常"><a class="markdownIt-Anchor" href="#1214-智能指针的异常"></a> 12.1.4 智能指针的异常</h3>
<p>在 new 之后在对应的 delete 之前发生了异常，则内存不会被释放。</p>
<p><strong>使用我们自己的释放操作</strong><br />
当我们创建一个 shared_ptr 时，可以传递一个指向删除器函数的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;connection&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;c, end_connection)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>当 p 被销毁时，它不会对自己保存的指针执行 delete，而是调用 end_connection。</p>
<h3 id="1215-unique_ptr"><a class="markdownIt-Anchor" href="#1215-unique_ptr"></a> 12.1.5 unique_ptr</h3>
<p>某个时刻只能有一个 unique_ptr 指向一个给定对象。初始化 unique_ptr 必须采用直接初始化形式。unique_ptr 不支持普通的拷贝或赋值操作。</p>
<p><strong>传递 unique_ptr 参数和返回 unique_ptr</strong><br />
有一个例外：我们可以拷贝或赋值一个将要被销毁的 unique_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">unique一<span class="hljs-function">ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br><span class="hljs-comment">// 正确：从 int* 创建一个 unique_ptr&lt;int&gt;</span><br>    <span class="hljs-keyword">return</span> unique_ptr&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(p));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>还可以返回一个局部对象的拷贝</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">clone</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> (p))</span></span>;<br>    <span class="hljs-comment">//… </span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>向 unique_ptr 传递删除器</strong><br />
unique_ptr 默认情况下用 delete 释放它指向的对象。<br />
必须在尖括号中 unique_ptr 指向类型之后提供删除器类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;objT, delT&gt; <span class="hljs-title">p</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> objT, fun)</span></span>;<br></code></pre></div></td></tr></table></figure>
<h3 id="1216-weak_ptr"><a class="markdownIt-Anchor" href="#1216-weak_ptr"></a> 12.1.6 weak_ptr</h3>
<p>weak_ptr 是一种不控制所指向对象生存期的智能指针。创建一个 weak_ptr 时，要用一个 shared_ptr 来初始化它。<br />
由于对象可能不存在，我们不能使用 weak_ptr 直接访问对象，而必须调用lock检查 weak_ptr 指向的对象是否仍存在。</p>
<h2 id="122-动态数组"><a class="markdownIt-Anchor" href="#122-动态数组"></a> 12.2 动态数组</h2>
<h3 id="1221-new-和数组"><a class="markdownIt-Anchor" href="#1221-new-和数组"></a> 12.2.1 new 和数组</h3>
<p><strong>分配一个数组会得到一个元素类型的指针</strong><br />
当用 new 分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。<br />
由于分配的内存并不是一个数组类型，因此不能对动态数组调用 begin 或 end，也不能用范围 for。</p>
<p><strong>动态分配一个空数组是合法的</strong><br />
当我们用 new 分配一个大小为0的数组时，new 返回一个合法的非空指针。此指针保证与 new 返回的其他任何指针都不相同，但此指针不能解引用。</p>
<p><strong>释放动态数组</strong><br />
销毁 p 指向的数组中的元素，并释放对应的内存，数组中的元素按逆序销毁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">delete</span> [] p; <span class="hljs-comment">// p 必须指向一个动态分配的数组或为空</span><br></code></pre></div></td></tr></table></figure>
<p><strong>智能指针和动态数组</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>[]&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>])</span></span>;<br>p.<span class="hljs-built_in">release</span> (); <span class="hljs-comment">// 自动用 delete [] 销毁其指针</span><br></code></pre></div></td></tr></table></figure>
<p>对于指向数组的 unique_ptr 我们不能使用点和箭头成员运算符，可以使用下标运算符来访问数组中的元素。<br />
shared_ptr 不直接支持管理动态数组。如果希望使用 shared_ptr 管理一个动态数组，必须提供自己定义的删除器。<br />
shared_ptr 未定义下标运算符，而且智能指针类型不支持指针算术运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i) &#123;<br>    *(sp.<span class="hljs-built_in">get</span>() + i) = i; <span class="hljs-comment">// 使用get获取一个内置指针</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="1222-allocator-类"><a class="markdownIt-Anchor" href="#1222-allocator-类"></a> 12.2.2 allocator 类</h3>
<p>allocator 分配的内存是原始的、未构造的。construct 成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">allocator&lt;string&gt; alloc; <span class="hljs-comment">// 可以分配 string 的 allocator 对象</span><br><span class="hljs-keyword">auto</span> <span class="hljs-keyword">const</span> p = alloc.<span class="hljs-built_in">allocate</span>(n); <span class="hljs-comment">// 分配 n 个未初始化的 string</span><br></code></pre></div></td></tr></table></figure>
<p>当我们用完对象后，必须对每个构造的元素调用 destroy 来销毁它们。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> q = p; <span class="hljs-comment">// q 指向最后构造的元素之后的位置</span><br>alloc.<span class="hljs-built_in">construct</span>(q++, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-comment">// *q 为 cccccccccc</span><br><span class="hljs-keyword">while</span> (q != p) &#123;<br>    alloc. <span class="hljs-built_in">destroy</span> (--q) ;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>释放内存通过调用 deallocate 来完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">alloc.<span class="hljs-built_in">deallocate</span>(p, n); <span class="hljs-comment">// n 就是 allocate(n) 时的大小</span><br></code></pre></div></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/C-Primer/">C++ Primer</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/CPP/">CPP</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/24/Leet/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LeetCode 刷题记录</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/27/CppPrimer1-7/">
                        <span class="hidden-mobile">笔记 C++ Primer 第一章~第七章</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"5e2153d92606f0f30050","clientSecret":"71138048e7eacddcadcf14ce72f87fe12fa35c40","repo":"Hinageshi01.github.io","owner":"Hinageshi01","admin":["Hinageshi01"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '6774a84f525ec7ce81fb2f1cfa434903'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <br/> 本站内容依据 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> 许可证进行授权 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.css" />
  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
