

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;dark&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Hinageshi">
  <meta name="keywords" content="">
  
  <title>笔记 C++ Primer 第一章~第七章 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":25,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["_slim",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":17057737,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Hinageshi的駄菓子屋</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archive
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/backGround.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="笔记 C++ Primer 第一章~第七章">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-27 00:08" pubdate>
        November 27, 2021
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      63
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">笔记 C++ Primer 第一章~第七章</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：November 27, 2021
                
              </p>
            
            <div class="markdown-body">
              <h1 id="序言"><a class="markdownIt-Anchor" href="#序言"></a> 序言</h1>
<p>《C++ Primer 5th Edition》前七章的读书笔记，只记录我认为重要/不熟悉的知识点，前七章刚好都属于不那么“C++”的部分，比较适合作为一个整理的节点。</p>
<h1 id="第一章-开始"><a class="markdownIt-Anchor" href="#第一章-开始"></a> 第一章 开始</h1>
<h2 id="12-初识输入输出"><a class="markdownIt-Anchor" href="#12-初识输入输出"></a> 1.2 初识输入输出</h2>
<p><code>#include &lt;iostream&gt;</code><br />
使用了 iostream 库，包含了 istream 类和 ostream 类，分别表示输入流和输出流。</p>
<h3 id="向流写入数据"><a class="markdownIt-Anchor" href="#向流写入数据"></a> 向流写入数据</h3>
<p>输出运算符（&lt;&lt;）接受两个运算对象，左侧必须是一个 ostream 对象，右侧是要打印的值，然后返回其左侧的对象。<br />
<code>std::endl</code><br />
这是一个被称为操作符的特殊值，写入 endl 的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。调试时应保证一直刷新流，避免程序崩溃时输出还留在缓冲区中。<br />
<code>std::cerr</code><br />
一个 ostream 对象，写到 cerr 的数据是不缓冲的。<br />
<code>std::clog</code><br />
一个 ostream 对象，写到 clog 的数据是被缓冲的。</p>
<h3 id="从流读取数据"><a class="markdownIt-Anchor" href="#从流读取数据"></a> 从流读取数据</h3>
<p>输入运算符（&gt;&gt;）接受两个运算对象，左侧必须是一个 istream 对象，右侧是要接收值的对象，然后返回其左侧的对象。</p>
<h2 id="14-控制流"><a class="markdownIt-Anchor" href="#14-控制流"></a> 1.4 控制流</h2>
<h3 id="143-读取数量不定的输入数据"><a class="markdownIt-Anchor" href="#143-读取数量不定的输入数据"></a> 1.4.3 读取数量不定的输入数据</h3>
<p><code>while(std::cin &gt;&gt; value)</code><br />
当我们使用一个 istream 对象作为条件时，其效果是检测流的状态。当遇到文件结束符，或遇到无效输入时，istream 对象的状态会变为无效。</p>
<h1 id="第二章-变量和基本类型"><a class="markdownIt-Anchor" href="#第二章-变量和基本类型"></a> 第二章 变量和基本类型</h1>
<h2 id="21-基本内置类型"><a class="markdownIt-Anchor" href="#21-基本内置类型"></a> 2.1 基本内置类型</h2>
<h3 id="211-算术类型"><a class="markdownIt-Anchor" href="#211-算术类型"></a> 2.1.1 算术类型</h3>
<p><strong>带符号类型和无符号类型</strong><br />
尽管字符型有三种<code>char</code>、<code>signed char</code>、<code>unsigned char</code>，字符的表现形式却只有两种：类型<code>char</code>实际上会表现为另两种的一种，具体是否带符号由编译器决定，所以使用字符型进行运算特别容易出问题。</p>
<h3 id="212-类型转换"><a class="markdownIt-Anchor" href="#212-类型转换"></a> 2.1.2 类型转换</h3>
<p>无符号超范围时取模，有符号超范围时结果未定义。<br />
<strong>含有无符号类型的表达式</strong><br />
当一个表达式里既有带符号数又有无符号数时，带符号数会自动转换成无符号数时。这个过程相当于将一个带符号数直接赋给成无符号变量，那么当带符号数为负时就会出现异常的结果。</p>
<h3 id="213-字面值查常量"><a class="markdownIt-Anchor" href="#213-字面值查常量"></a> 2.1.3 字面值查常量</h3>
<p><strong>字符字面值和字串符字面值</strong><br />
字符串字面值的类型实际上是由常量字符构成的数组。编译器在每个字符串的结尾处添加一个空字符(’\0’)，因此，字符串字面值的实际长度要比它的内容多1。<br />
如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一 个整体。</p>
<h2 id="22-变量"><a class="markdownIt-Anchor" href="#22-变量"></a> 2.2 变量</h2>
<h3 id="221-变量定义"><a class="markdownIt-Anchor" href="#221-变量定义"></a> 2.2.1 变量定义</h3>
<p><strong>默认初始化</strong><br />
定义于任何函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量将不被初始化。string 类规定如果没有指定初值则生成一个空串。</p>
<h3 id="222-变量声明和定义的关系"><a class="markdownIt-Anchor" href="#222-变量声明和定义的关系"></a> 2.2.2 变量声明和定义的关系</h3>
<p>声明使得名字为程序所知。而定义负责创建与名字关联的实体。变量声明规定了变量的类型和名字。定义还申请存储空间，也可能会为变量赋一个初始值。<br />
<strong>extern</strong><br />
如果想声明一个变量而非定义它，就在变量名前添加关键字 extern，而且不要显式地初始化变量。extern 语句如果包含初始值就不再是声明，而变成定义了。变量能且只能被定义一次，但是可以被多次声明。<br />
如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p>
<h2 id="23-复合类型"><a class="markdownIt-Anchor" href="#23-复合类型"></a> 2.3 复合类型</h2>
<h3 id="231-引用"><a class="markdownIt-Anchor" href="#231-引用"></a> 2.3.1 引用</h3>
<p>因为无法令引用重新绑定到另外一个对象，因此引用必须初始化为一个对象。因为引用本身不是一个对象，所以不能定义引用的引用。</p>
<h2 id="24-const-限定符"><a class="markdownIt-Anchor" href="#24-const-限定符"></a> 2.4 const 限定符</h2>
<h3 id="241-const-的引用"><a class="markdownIt-Anchor" href="#241-const-的引用"></a> 2.4.1 const 的引用</h3>
<p>所谓常量引用是对常量的引用，因为引用不是一个对象，所以不存在常量引用。在初始化常量引用时允许用任意表达式作为初始值，此时该引用会绑定到一个临时量对象（常量）上，而与原本等号右侧的表达式几乎不相关。</p>
<h3 id="242-指针和-const"><a class="markdownIt-Anchor" href="#242-指针和-const"></a> 2.4.2 指针和 const</h3>
<p>允许一个指向常量的指针指向一个非常量对象，所谓的底层 const，不过是指针或引用自己认为自己指向了常量，然后自觉地不去改变所指对象的值。</p>
<h3 id="243-顶层-const"><a class="markdownIt-Anchor" href="#243-顶层-const"></a> 2.4.3 顶层 const</h3>
<p>用于声明引用的 const 都是底层 const。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。</p>
<h3 id="244-constexpr-表达式"><a class="markdownIt-Anchor" href="#244-constexpr-表达式"></a> 2.4.4 constexpr 表达式</h3>
<p>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。显然字面值属于常量表达式，用常量表达式初始化的 const 对象也是常量表达式。<br />
将变量声明为 constexpr 类型以便由编译器来验证变量的值是否是一个常量表达式。<br />
<strong>字面值类型</strong><br />
算术类型、引用和指针都属于字面值类型。一个 constexpr 指针的初始值必须是 nullptг 或者 0，或者是存储于某个固定地址中的对象（定义于所有函数体之外的变量）。<br />
<strong>指针和 constexpr</strong><br />
在 constexpr 声明中如果定义了一个指针，无论限定符 constexpr 出现在什么位置，都仅对指针生效，与指针所指的对象无关。</p>
<h2 id="25-处理类型"><a class="markdownIt-Anchor" href="#25-处理类型"></a> 2.5 处理类型</h2>
<h3 id="251-类型别名"><a class="markdownIt-Anchor" href="#251-类型别名"></a> 2.5.1 类型别名</h3>
<p>使用<code>typedef char *pstr;</code>或<code>using pstr = char *;</code><br />
注意<code>const pstr cstr</code>不等于<code>const char *cstr</code>，就像是类型别名决定了声明中结合的优先级一样。</p>
<h3 id="252-auto-类型说明符"><a class="markdownIt-Anchor" href="#252-auto-类型说明符"></a> 2.5.2 auto 类型说明符</h3>
<p>auto —般会忽略掉顶层 const，如果希望推断出的 auto 类型是一个顶层 const，需要明确指出。</p>
<h3 id="253-decltype-类型指示符"><a class="markdownIt-Anchor" href="#253-decltype-类型指示符"></a> 2.5.3 decltype 类型指示符</h3>
<p>编译器分析表达式并得到它的类型，却不实际计算表达式的值。decltype 完整地保留参数的类型，包括 const 与引用。<br />
<strong>decltype 和引用</strong><br />
如果表达式的内容是解引用操作，则decltype将得到引用类型。如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。如果表达式的求值结果是左值，decltype 得到一个引用类引用型。因为变量是一种可以作为赋值语句左值的特殊表达式，所以这样的 decltype 就会得到引用类型。<br />
切记：<code>decltype((variaide))</code>的结果永远是引用类型。</p>
<h3 id="263-编写自己的头文件"><a class="markdownIt-Anchor" href="#263-编写自己的头文件"></a> 2.6.3 编写自己的头文件</h3>
<p>有必要在书写 头文件时做适当处理，使其遇到多次包含情况也能安全和正常地工作。<br />
<strong>预处理器概述</strong><br />
预处理器是在编译之前执行的一段程序。<br />
<strong>头文件保护符</strong><br />
头文件保护符依赖于预处理变量。<br />
<code>#define</code>指令把一个名字设定为预处理变量。<br />
<code>#ifdef</code>当且仅当变量已定义时为真。<br />
<code>#ifndef</code>当且仅当变量未定义时为真，一旦检查结果为真，则执行后续操作直至遇到<code>#endif</code>指令为止。<br />
整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> CLASS_NAME_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLASS_NAME_H</span><br><span class="hljs-comment">// 各种包含与定义。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<h1 id="第三章-字符串-向量和数组"><a class="markdownIt-Anchor" href="#第三章-字符串-向量和数组"></a> 第三章 字符串、向量和数组</h1>
<h2 id="32-标准库类型-string"><a class="markdownIt-Anchor" href="#32-标准库类型-string"></a> 3.2 标准库类型 string</h2>
<h3 id="321-定义和初始化-string-对象"><a class="markdownIt-Anchor" href="#321-定义和初始化-string-对象"></a> 3.2.1 定义和初始化 string 对象</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>)</span></span>; <span class="hljs-comment">// s 的内容是 cccccccccc</span><br>string s2 = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 拷贝初始化</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>; <span class="hljs-comment">// 直接初始化</span><br></code></pre></div></td></tr></table></figure>
<p><strong>读写 string 对象</strong><br />
string 对象会自动忽略开头的空白，直到遇见下一处空白为止。<br />
<strong>使用 getline 读取一整行</strong><br />
getline 函数的参数是一个输入流和一个 string 对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个 string 对象中去（注意不存换行符)。<br />
<strong>string::size_type 类型</strong><br />
size() 函数返回的是一个 string::size_type类型的值，它是一 个无符号类型的值（参见2.1.1节，第30页）而且能足够存放下任何string对象的大小。如果一条表达式中已经有了 size() 函数就不要再使用 int 了，这样可以避免<br />
混用 int 和 unsigned 可能带来的问题。</p>
<h2 id="33-标准库类型-vector"><a class="markdownIt-Anchor" href="#33-标准库类型-vector"></a> 3.3 标准库类型 vector</h2>
<p>因为引用不是对象，所以不存在包含引用的 vector。</p>
<h3 id="331-定义和初始化-vector-对象"><a class="markdownIt-Anchor" href="#331-定义和初始化-vector-对象"></a> 3.3.1 定义和初始化 vector 对象</h3>
<p><strong>值初始化</strong><br />
可以只提供 vector 对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由 vector 对象中元素的类型决定。如果 vector 对象的元素是内置类型，比如 int，则元素初始值自动设为 0。如果元素是某种类类型，比如 string，则元素由类默认初始化。<br />
如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造 vector 对象了。</p>
<h2 id="34-迭代器介绍"><a class="markdownIt-Anchor" href="#34-迭代器介绍"></a> 3.4 迭代器介绍</h2>
<h3 id="341-使用迭代器"><a class="markdownIt-Anchor" href="#341-使用迭代器"></a> 3.4.1 使用迭代器</h3>
<p><code>vector&lt;Type&gt;::iterator</code>与<code>vector&lt;Type&gt;::const_iterator</code>类型<br />
<strong>结合解引用与成员访问操作</strong><br />
<code>(*it).mem();</code>括号必不可少。为了简化上述表达式，C++ 语言定义了箭头运算符（-&gt;）。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，<code>it-&gt;mem</code>和<code>(*it) .mem</code>表达的意思相同。<br />
任何一种可能改变 vector 对象容量的操作，比如 push_back，都会使该 vector 对象的迭代器失效。<br />
两个迭代器相减所得结果的类型是名为 difference_type 的带符号整型数。</p>
<h2 id="35-数组"><a class="markdownIt-Anchor" href="#35-数组"></a> 3.5 数组</h2>
<p>数组的大小确定不变，维度必须是一个常量表达式，必须指定类型，不存在引用的数组，不允许拷贝和赋值。<br />
<strong>复杂的数组声明</strong><br />
<code>int *(&amp;arry)[10] = prts; // 首先arry是一个引用，引用对象为大小为10的数组，数组类型是指向int的指针</code></p>
<h3 id="353-指针和数组"><a class="markdownIt-Anchor" href="#353-指针和数组"></a> 3.5.3 指针和数组</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>; <span class="hljs-comment">// ia2是指向is第一个元素的指针</span><br><span class="hljs-keyword">decltype</span>(ia) ia3 = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// ia3是长度为5的整型数组</span><br></code></pre></div></td></tr></table></figure>
<p><strong>标准库函数 begin 和 end</strong><br />
begin() 函数返回指向数组首元素的指针，end() 函数返回指向数组尾元素下一位置的指针，这两个函数定义在 iterator 头文件中。<br />
<strong>指针运算</strong><br />
两个指针相减的结果的类型是一种名为 ptrdiff_t 的标准库类型，和 size_t —样，ptrdiff_t 也是一种定义在 cstddef 头文件中的机器相关的类型。因为差值可能为负值，所以 ptrdiff_t 是一种带符号类型。</p>
<h3 id="354-c-风格字符串"><a class="markdownIt-Anchor" href="#354-c-风格字符串"></a> 3.5.4 C 风格字符串</h3>
<p>string 类提供了 c_str() 函数，返回的是一个 C 风格字符串。<br />
允许使用数组来初始化 vector 对象。<br />
<code>vectro&lt;int&gt; ivec(begin(int_arr), end(int_arr));</code></p>
<h2 id="36-多维数组"><a class="markdownIt-Anchor" href="#36-多维数组"></a> 3.6 多维数组</h2>
<p><code>int ia[3][4] = &#123;&#123;0&#125;, &#123;1&#125;, &#123;3&#125;&#125;; // 显示地初始化每行的首元素</code><br />
要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型，否则 auto 的类型会是一个指针。</p>
<h1 id="第四章-表达式"><a class="markdownIt-Anchor" href="#第四章-表达式"></a> 第四章 表达式</h1>
<h2 id="41-基础"><a class="markdownIt-Anchor" href="#41-基础"></a> 4.1 基础</h2>
<h3 id="411-基本概念"><a class="markdownIt-Anchor" href="#411-基本概念"></a> 4.1.1 基本概念</h3>
<p><strong>运算对象转换</strong><br />
小整数类型（如 bool、char、short 等）通常会被提升成较大的整数类型，主要是 int。</p>
<h3 id="413-求值顺序"><a class="markdownIt-Anchor" href="#413-求值顺序"></a> 4.1.3 求值顺序</h3>
<p>编译器不会明确指定表达式中运算对象的求值顺序。<code>i++ + ++i</code>自然是未定义的操作。</p>
<h2 id="42-算术运算符"><a class="markdownIt-Anchor" href="#42-算术运算符"></a> 4.2 算术运算符</h2>
<p>m%(-n)=m%n; (-m)%n=-(m%n)</p>
<h2 id="44-赋值运算符"><a class="markdownIt-Anchor" href="#44-赋值运算符"></a> 4.4 赋值运算符</h2>
<p>右侧运算对象将转换成左侧运算对象的类型，赋值运算返回的是其左侧运算对象。<br />
复合运算符只求值一次。</p>
<h2 id="45-递增和递减运算符"><a class="markdownIt-Anchor" href="#45-递增和递减运算符"></a> 4.5 递增和递减运算符</h2>
<p>前置版本将更新后的对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。除非必须，否则不用递增递减运算符的后置版本。</p>
<h2 id="47-条件运算符"><a class="markdownIt-Anchor" href="#47-条件运算符"></a> 4.7 条件运算符</h2>
<p>条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通 常需要在它两端加上括号。</p>
<h2 id="48-位运算符"><a class="markdownIt-Anchor" href="#48-位运算符"></a> 4.8 位运算符</h2>
<p>如果运算对象是带符号的且它的值为负，那么位运算符如何处理运算对象的“符号位”依赖于机器。而且, 此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。<br />
左移运算符（&lt;&lt;）在右侧插入值为 0 的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为 0 的二进制位: 如果该运算对象是带符号类型，在左侧插入符号位的副本或值为 0 的二进制位。</p>
<h2 id="411-类型转换"><a class="markdownIt-Anchor" href="#411-类型转换"></a> 4.11 类型转换</h2>
<h3 id="4111-算术转换"><a class="markdownIt-Anchor" href="#4111-算术转换"></a> 4.11.1 算术转换</h3>
<p>算数表达式中运算符的运算对象将转换成最宽的类型。<br />
带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。</p>
<h3 id="其他隐式类型转换"><a class="markdownIt-Anchor" href="#其他隐式类型转换"></a> 其他隐式类型转换</h3>
<p>包括常量整数值 0 或者字面值 nullptr 能转换成任意指针类型。指向任意非常量的指针能转换成 void*。指向任意对象的指针能转换成 const void*。</p>
<h3 id="4113-显示转换"><a class="markdownIt-Anchor" href="#4113-显示转换"></a> 4.11.3 显示转换</h3>
<p><strong>static_cast</strong><br />
任何具有明确定义的类型转换，只要不包含底层 const，都可以使用 static_cast。<br />
<strong>const_cast</strong><br />
const_cast只能改变运算对象的底层 const。<br />
<strong>reinterpret_cast</strong><br />
通常为运算对象的位模式提供较低层次上的重新解释。reinterpret_cast 本质上依赖于机器且非常危险。<br />
<strong>旧式的强制转换</strong><br />
<code>type(exper)</code>或<code>(type)exper</code><br />
如果替换为 static_cast 或 const_cast 也合法，则执行与他们相似的行为，否则执行与 reinterpret_cast 相似的行为。</p>
<h1 id="第五章-语句"><a class="markdownIt-Anchor" href="#第五章-语句"></a> 第五章 语句</h1>
<h2 id="56-try-语句和异常处理"><a class="markdownIt-Anchor" href="#56-try-语句和异常处理"></a> 5.6 try 语句和异常处理</h2>
<p>抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。<br />
在 try 中 throw 异常，然后层层查找符合的 catch。如果最终还是没能找到任何匹配的catch子句，程序转到名为 terminate 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。</p>
<h1 id="第六章-函数"><a class="markdownIt-Anchor" href="#第六章-函数"></a> 第六章 函数</h1>
<h2 id="61-函数基础"><a class="markdownIt-Anchor" href="#61-函数基础"></a> 6.1 函数基础</h2>
<p><strong>形参和实参</strong><br />
实参是形参的初始值。编译器能以任意可行的顺序对实参求值。</p>
<h3 id="611-局部对象"><a class="markdownIt-Anchor" href="#611-局部对象"></a> 6.1.1 局部对象</h3>
<p><strong>自动对象</strong><br />
我们把只存在于块执行期间的对象称为自动对象。<br />
<strong>局部静态对象</strong><br />
局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。<br />
如果局部静态变量没有显式的初始值，它将执行值初始化。</p>
<h2 id="62-参数传递"><a class="markdownIt-Anchor" href="#62-参数传递"></a> 6.2 参数传递</h2>
<h3 id="623-const-形参和实参"><a class="markdownIt-Anchor" href="#623-const-形参和实参"></a> 6.2.3 const 形参和实参</h3>
<p>当用实参初始化形参时会忽略掉顶层 const。换句话说，形参的顶层 const 被忽略掉了。<br />
<strong>尽量使用常量引用</strong><br />
一个非常量引用的形参无法接受一个常量的实参</p>
<h3 id="624-数组形参"><a class="markdownIt-Anchor" href="#624-数组形参"></a> 6.2.4 数组形参</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>])</span></span>;<br><span class="hljs-comment">// 这三个函数是等价的。</span><br></code></pre></div></td></tr></table></figure>
<p><strong>数组引用形参</strong><br />
形参是数组的引用，维度是类型的一部分。<br />
<code>void fun(int (&amp;arr)[10]);</code><br />
<strong>传递多维数组</strong><br />
数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略：<br />
<code>void fun(int (*mat)[10])</code></p>
<h3 id="626-含有可变形参的函数"><a class="markdownIt-Anchor" href="#626-含有可变形参的函数"></a> 6.2.6 含有可变形参的函数</h3>
<p><strong>initializer_list 形参</strong><br />
实参数量未知但是全部实参的类型都相同，initializer_list 也是一种模板类型，对象中的元素永远是常量值。如果想向 initializer_list 形参中传递一个值的序歹，则必须把序列放在一对花括号内：<br />
<code>fun(&#123;a, b, c&#125;);</code><br />
<strong>省略符形参</strong><br />
省略符形参只能出现在形参列表的最后一个位置，大多数类类型的对象在传递给省略符形参时都无法正确拷贝，省略符形参所对应的实参无须类型检查。<br />
<code>void fun(int a, ...)</code></p>
<h2 id="63-返回类型和-return-语句"><a class="markdownIt-Anchor" href="#63-返回类型和-return-语句"></a> 6.3 返回类型和 return 语句</h2>
<h3 id="631-无返回值函数"><a class="markdownIt-Anchor" href="#631-无返回值函数"></a> 6.3.1 无返回值函数</h3>
<p>在这类函数的最后一句后面会隐式地执行 return。一个返冋类型是 void 的函数也能返回另一个返回 void 的函数。</p>
<h3 id="632-有返回值函数"><a class="markdownIt-Anchor" href="#632-有返回值函数"></a> 6.3.2 有返回值函数</h3>
<p>返冋的值用于初始化调 用点的一个临时量，该临时量就是函数调用的结果。</p>
<h3 id="633-返回数组指针"><a class="markdownIt-Anchor" href="#633-返回数组指针"></a> 6.3.3 返回数组指针</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> arrT[<span class="hljs-number">10</span>]; <span class="hljs-comment">// arrT的类型是长度为10的int数组</span><br><span class="hljs-keyword">using</span> arrT = <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 等价</span><br></code></pre></div></td></tr></table></figure>
<p>返回数组指针的函数形如：<br />
<code>Type(*fun(par_list))[dim]</code><br />
<strong>使用尾置返回类型</strong><br />
尾置返冋类型跟在形参列表后面并以一个（-&gt;）符号开头。在本应该出现返回类型的地方放置一个 auto。<br />
<code>auto fun(int i) -&gt; int (*) [10];</code><br />
注意：decltype 并不负责把数组类型转换成对应的指针。</p>
<h2 id="64-函数重载"><a class="markdownIt-Anchor" href="#64-函数重载"></a> 6.4 函数重载</h2>
<p>一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参R分开来。</p>
<h2 id="65-特殊用途语言特性"><a class="markdownIt-Anchor" href="#65-特殊用途语言特性"></a> 6.5 特殊用途语言特性</h2>
<h3 id="651-默认实参"><a class="markdownIt-Anchor" href="#651-默认实参"></a> 6.5.1 默认实参</h3>
<p>为了使得窗口函数既能接纳默认值，也能接受用户指定的值，我们把它定义成如下的形式：<br />
<code>void fun(int a, int b = 0, int c = 1);</code><br />
一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值，默认实参负责填补函数调用缺少的尾部实参。<br />
用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时。</p>
<h3 id="652-内联函数和-constexpr-函数"><a class="markdownIt-Anchor" href="#652-内联函数和-constexpr-函数"></a> 6.5.2 内联函数和 constexpr 函数</h3>
<p><strong>内联函数可避免函数调用的开销</strong><br />
在函数的返回类型前面加上关键字 inline，内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。<br />
<strong>constexpr 函数</strong><br />
函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条 return 语句。<br />
编译器把对 constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr 函数被隐式地指定为内联函数。<br />
我们允许 constexpr 函数的返回值并非一个常量。</p>
<h3 id="653-调试帮助"><a class="markdownIt-Anchor" href="#653-调试帮助"></a> 6.5.3 调试帮助</h3>
<p><code>assert(expr);</code><br />
如果表达式为真（即非0），assert 什么也不做。assert 宏常用于检查“不能发生”的条件。<br />
<strong>NDEBUG 预处理变量</strong><br />
<code>#define NDEBUG</code><br />
如果定义了 NDEBUG, 则 assert 什么也不做。定义 NDEBUG 能避免检查各种条件所需的运行时开销。</p>
<h2 id="66-函数匹配"><a class="markdownIt-Anchor" href="#66-函数匹配"></a> 6.6 函数匹配</h2>
<p><strong>确定候选函数和可行函数</strong><br />
候选函数：一是与被调用的函数同名，二是其声明在调用点可见。<br />
可行函数：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。<br />
<strong>寻找最佳匹配</strong><br />
如果有且只有一个函数满足下列条件，则匹配成功：</p>
<ul>
<li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配。</li>
</ul>
<p>如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报 告二义性调用的信息。</p>
<h2 id="67-函数指针"><a class="markdownIt-Anchor" href="#67-函数指针"></a> 6.7 函数指针</h2>
<p><strong>使用函数指针</strong><br />
当我们把函数名作为一个值使用时，该函数自动地转换成指针（取地址符可选）<br />
我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针（解引用符可选）<br />
在指向不同函数类型的指针间不存在转换规则。<br />
<strong>函数指针形参</strong><br />
形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fun2())</span></span>; <span class="hljs-comment">// 形参是函数类型，它会自动地转换成指向函数的指针。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*fun2)())</span></span>; <span class="hljs-comment">// 显式地将形参定义成指向函数的指针。</span><br></code></pre></div></td></tr></table></figure>
<p>直接把函数作为实参使用，此时它会自动转换成指针。<br />
<code>fun1(fun);</code><br />
<strong>返回指向函数的指针</strong><br />
编译器不会自动地将函数返回类型当成对应的指针类型处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> F = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>();<br><span class="hljs-keyword">using</span> PF = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*)();<br><br><span class="hljs-function">PF <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// PF是指向函数的指针，fl返回指向函数的指针。</span><br><span class="hljs-function">F *<span class="hljs-title">fi</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 显式地指定返回类型是指向函数的指针。</span><br></code></pre></div></td></tr></table></figure>
<h1 id="第七章-类"><a class="markdownIt-Anchor" href="#第七章-类"></a> 第七章 类</h1>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/CPP/">CPP</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/08/SimpleRenderer/">
                        <span class="hidden-mobile">Simple Renderer</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"5e2153d92606f0f30050","clientSecret":"71138048e7eacddcadcf14ce72f87fe12fa35c40","repo":"Hinageshi01.github.io","owner":"Hinageshi01","admin":["Hinageshi01"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '6ae3868f7fea00fa57f15b02453109e5'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <br/> 本站内容依据 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> 许可证进行授权 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.css" />
  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
