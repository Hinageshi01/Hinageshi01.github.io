

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;dark&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Hinageshi">
  <meta name="keywords" content="">
  
  <title>笔记 C++ Primer 第十三章~第十六章 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":25,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["_slim",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":17057737,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Hinageshi的駄菓子屋</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archive
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/backGround.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="笔记 C++ Primer 第十三章~第十六章">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-24 23:03" pubdate>
        January 24, 2022
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      151
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">笔记 C++ Primer 第十三章~第十六章</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：February 18, 2022
                
              </p>
            
            <div class="markdown-body">
              <h1 id="序言"><a class="markdownIt-Anchor" href="#序言"></a> 序言</h1>
<p>  《C++ Primer 5th Edition》类设计者工具部分的读书笔记。</p>
<h1 id="第十三章-拷贝控制"><a class="markdownIt-Anchor" href="#第十三章-拷贝控制"></a> 第十三章 拷贝控制</h1>
<h2 id="131-拷贝-赋值与销毁"><a class="markdownIt-Anchor" href="#131-拷贝-赋值与销毁"></a> 13.1 拷贝、赋值与销毁</h2>
<h3 id="1311-拷贝构造函数"><a class="markdownIt-Anchor" href="#1311-拷贝构造函数"></a> 13.1.1 拷贝构造函数</h3>
<p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值， 则此构造函数是拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span> (<span class="hljs-keyword">const</span> Foo&amp;); <span class="hljs-comment">//拷贝构造函数</span><br>&#125;；<br></code></pre></div></td></tr></table></figure>
<p><strong>合成拷贝构造函数</strong><br />
合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中，并且会逐元素地拷贝一个数组类型的成员。</p>
<h3 id="1313-析构函数"><a class="markdownIt-Anchor" href="#1313-析构函数"></a> 13.1.3 析构函数</h3>
<p>析构函数的名字由波浪号接类名构成，它没有返回值，不接受参数，也不能被重载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    〜<span class="hljs-built_in">Foo</span>(); <span class="hljs-comment">//析构函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><strong>析构函数完成什么工作</strong><br />
在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。<br />
成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。<br />
隐式销毁一个内置指针类型的成员不会delete它所指向的对象。与普通指针不同，智能指针成员在析构阶段会被自动销毁。</p>
<p><strong>什么时候会调用析构函数</strong><br />
无论何时一个对象被销毁，就会自动调用其析构函数。<br />
当指向一个对象的引用或指针离开作用域时，析构函数不会执行。</p>
<p><strong>合成析构函数</strong><br />
析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。</p>
<h3 id="1314-三五法则"><a class="markdownIt-Anchor" href="#1314-三五法则"></a> 13.1.4 三/五法则</h3>
<p><strong>需要析构函数的类也需要拷贝和赋值操作</strong><br />
合成析构函数不会delete—个指针数据成员。因此，此类需要定义一个析构函数来释放构造函数分配的内存。</p>
<p><strong>合成的拷贝构造函数和拷贝</strong><br />
赋值运算符简单拷贝指针成员，这意味着多个指针可能指向相同的内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">HasPtr <span class="hljs-title">f</span> <span class="hljs-params">(HasPtr hp)</span> &#125; <span class="hljs-comment">// HasPtr 是传值参数，所以将被拷贝</span></span><br><span class="hljs-function">    HasPtr ret </span>= hp; <span class="hljs-comment">// 拷贝给定的 HasPtr</span><br>    <span class="hljs-keyword">return</span> ret;	<span class="hljs-comment">// ret 和 hp 被销毁</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>当 f 返回时，hp 和 ret 都被销毁。此代码会导致此指针被 delete 两次，将要发生什么是未定义的。</p>
<p><strong>需要拷贝搡作的类也需要赋值操作，反之亦然</strong></p>
<h3 id="1315-使用-default"><a class="markdownIt-Anchor" href="#1315-使用-default"></a> 13.1.5 使用 =default</h3>
<p>如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用 =default。</p>
<h3 id="1316-阻止拷贝-delete"><a class="markdownIt-Anchor" href="#1316-阻止拷贝-delete"></a> 13.1.6 阻止拷贝 =delete</h3>
<p>可以将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。我们虽然声明了删除的函数，但不能以任何方式使用它们。<br />
与 =default 不同，=delete 必须出现在函数第一次声明的时候。</p>
<p><strong>析构函数不能是删除的成员</strong><br />
对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象。<br />
如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类的变量或临时对象。<br />
对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象。</p>
<p><strong>合成的拷贝控制成员可能是删除的</strong><br />
如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p>
<h2 id="132-拷贝控制和资源管理"><a class="markdownIt-Anchor" href="#132-拷贝控制和资源管理"></a> 13.2 拷贝控制和资源管理</h2>
<p>通常，管理类外资源的类必须定义拷贝控制成员。</p>
<h3 id="1321-行为像值的类"><a class="markdownIt-Anchor" href="#1321-行为像值的类"></a> 13.2.1 行为像值的类</h3>
<p><strong>类值拷贝赋值运算符</strong><br />
类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。<br />
如果将一个对象赋予它自身，赋值运算符必须能正确工作。<br />
大多数赋值运算符组合了析构函数和拷贝构造函数的工作，当右侧拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。</p>
<h3 id="1322-定义行为像指针的类"><a class="markdownIt-Anchor" href="#1322-定义行为像指针的类"></a> 13.2.2 定义行为像指针的类</h3>
<p>令一个类展现类似指针的行为的最好方法是使用 shared_ptr 来管理类中的资源。</p>
<h2 id="136-对象移动"><a class="markdownIt-Anchor" href="#136-对象移动"></a> 13.6 对象移动</h2>
<p>在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。<br />
使用移动而不是拷贝的另一个原因源于 IO 类或 unique_ptr 这样的类都包含不能被共享的资源（如指针或IO缓冲）。因此，这些类型对象不能拷贝但可以移动。</p>
<h3 id="1361-右值引用"><a class="markdownIt-Anchor" href="#1361-右值引用"></a> 13.6.1 右值引用</h3>
<p>右值引用只能绑定到一个将要销毁的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r = i * <span class="hljs-number">42</span>; <span class="hljs-comment">// 正确：我们可以将一个 const 的引用绑定到一个右值上</span><br><span class="hljs-keyword">int</span> &amp;&amp;rr = i * <span class="hljs-number">42</span>; <span class="hljs-comment">// 正确：将 rr 绑定到乘法结果上</span><br></code></pre></div></td></tr></table></figure>
<p><strong>左值持久；右值短暂</strong></p>
<ul>
<li>所引用的对象将要被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p>这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。</p>
<p><strong>变量是左值</strong><br />
变量表达式都是左值，所以我们不能将一个右值引用绑定到一个右值引用类型的变量上。</p>
<p><strong>标准库 move 函数</strong><br />
可以显式地将一个左值转换为对应的右值引用类型。<br />
还可以通过调用一个名为 move 的新标准库函数来获得绑定到左值上的右值引用。<br />
move 调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。<br />
调用 move 就意味着承诺：除了对rrl赋值或销毁它外，我们将不再使用它，我们不能对移后源对象的值做任何假设。<br />
我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。</p>
<h3 id="1362-移动构造函数和移动赋值运算符"><a class="markdownIt-Anchor" href="#1362-移动构造函数和移动赋值运算符"></a> 13.6.2 移动构造函数和移动赋值运算符</h3>
<p>为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符，它们从给定对象“窃取”资源而不是拷贝资源。<br />
移动构造函数的第一个参数是该类类型的一个右值引用，任何额外的参数都必须有默认实参。<br />
移动构造函数还必须确保销毁移后源对象是无害的。一旦资源完成移动，源对象必须不再指向被移动的资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">StrVec::<span class="hljs-built_in">StrVec</span> (StrVec &amp;&amp;s) <span class="hljs-keyword">noexcept</span><br>:<span class="hljs-built_in">elements</span>(s.elements), <span class="hljs-built_in">first_free</span>(s.first_free), <span class="hljs-built_in">cap</span>(s.cap)<br>&#123;<br>    <span class="hljs-comment">// 令 s 进入这样的状态：对其运行析构函数是安全的</span><br>    s.elements = s.first_free = s.cap = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>移动操作、标准库容器和异常</strong><br />
除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。<br />
noexcept 是我们承诺一个函数不抛出异常的一种方法。在一个构造函数中，noexcept 出现在参数列表和初始化列表开始的冒号之间。<br />
如果重新分配过程使用了移动构造函数，且在移动了部分而不是全部元素后抛出了一个异常，就会产生问题：旧空间中的移动源元素已经被改变了，而新空间中未构造的元素可能尚不存在。<br />
为了避免这种潜在问题，除非 vector 知道元素类型的移动构造函数不会抛出异常， 否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。如果希望在 vector 重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就必须显式地告诉标准库我们的移动构造函数可以安全使用。我们通过将移动构造函数（及移动赋值运算符）标记为 noexcept 来做到这一点。</p>
<p><strong>移动赋值运算符</strong><br />
移动赋值运算符不抛出任何异常，移动赋值运算符必须正确处理自赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">StrVec SStrVec::<span class="hljs-keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span> &#123;<br>    <span class="hljs-comment">// 直接检测自賦值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>        <span class="hljs-built_in">free</span>();<br>        elements = rhs.elements; <span class="hljs-comment">// 从 rhs 接管资源</span><br>        first_free = rhs.first_free;<br>        cap = rhs.cap;<br>        <span class="hljs-comment">// 将 rhs 置于可析构状态</span><br>        rhs.elements = rhs.first_free = rhs.cap = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>移后源对象必须可析构</strong><br />
在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设</p>
<p><strong>合成的移动操作</strong><br />
如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。<br />
只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成 员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。<br />
移动操作永远不会隐式定义为删除的函数，如果我们显式地要求编译器生成 =default 的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。<br />
如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。</p>
<p><strong>移动右值，拷贝左值……</strong><br />
如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。</p>
<p><strong>……但如果没有移动构造函数，右值也被拷贝</strong><br />
如果一个类有一个拷贝构造函数但未定义移动构造函数，编译器不会合成移动构造函数</p>
<p><strong>移动迭代器</strong><br />
移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器，移动迭代器的解引用运算符生成一个右值引用。<br />
通过调用标准库的 make_move_iterator 函数将一个普通迭代器转换为一个移动迭代器。</p>
<h3 id="1363-右值引用和成员函数"><a class="markdownIt-Anchor" href="#1363-右值引用和成员函数"></a> 13.6.3 右值引用和成员函数</h3>
<p><strong>右值和左值引用成员函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">sl + s2 = <span class="hljs-string">&quot;wow!&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>此处我们对两个 string 的连接结果（右值），进行了赋值。新标准库类仍然允许向右值赋值，阻止这种用法的方式是在参数列表后放置一个引用限定符。<br />
引用限定符可以是 &amp; 或 &amp;&amp;，分别指出 this 可以指向一个左值或右值。类似 const 限定符, 引用限定符只能用于（非 static）成员函数，且必须同时出现在函数的声明和定义中。引用限定符必须跟随在 const 限定符之后。</p>
<p><strong>重载和引用函数</strong><br />
如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加。</p>
<h1 id="第十四章-重载运算与类型转换"><a class="markdownIt-Anchor" href="#第十四章-重载运算与类型转换"></a> 第十四章 重载运算与类型转换</h1>
<h2 id="141-基本概念"><a class="markdownIt-Anchor" href="#141-基本概念"></a> 14.1 基本概念</h2>
<p>重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。<br />
除了重载的函数调用运算符 operator() 之外，其他重载运算符不能含有默认实参。<br />
如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的 this 指针上。<br />
对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数，这意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。<br />
我们无权发明新的运算符号。<br />
重载的运算符的优先级和结合律与对应的内置运算符保持一致。</p>
<p><strong>某些运算符不应该被重载</strong><br />
因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。</p>
<p><strong>选择作为成员或者非成员</strong></p>
<ul>
<li>赋值、下标、调用和成员访问箭头运算符必须是成员</li>
<li>复合赋值运算符一般来说应该是成员</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，通常应该是成员</li>
<li>具有对称性的运算符可能转换任意一端的运算对象，通常应该是普通的非成员函数</li>
</ul>
<p>当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。</p>
<h2 id="142-输入和输出运算符"><a class="markdownIt-Anchor" href="#142-输入和输出运算符"></a> 14.2 输入和输出运算符</h2>
<h3 id="1421-重载输出运算符"><a class="markdownIt-Anchor" href="#1421-重载输出运算符"></a> 14.2.1 重载输出运算符 &lt;&lt;</h3>
<p>输出运算符的第一个形参是一个非常量 ostream 对象的引用，第二个形参一般来说是一个常量的引用，一般要返回它的 ostream 形参。</p>
<p><strong>输入输出运算符必须是非成员函数</strong><br />
IO 运算符通常需要读写类的非公有数据成员，所以 IO 运算符一般被声明为友元。</p>
<h3 id="1422-重载输人运算符"><a class="markdownIt-Anchor" href="#1422-重载输人运算符"></a> 14.2.2 重载输人运算符 &gt;&gt;</h3>
<p>常会返回某个给定流的引用。<br />
输入运算符必须处理输入可能失败的情况，而输出运算符不需要。<br />
如果在发生错误前对象已经有一部分被改变，则适时地将对象置为合法状态显得异常重要。</p>
<h2 id="143-算术和关系运算符"><a class="markdownIt-Anchor" href="#143-算术和关系运算符"></a> 14.3 算术和关系运算符</h2>
<p>通常把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。<br />
操作完成后返回该局部变量的副本作为其结果。<br />
如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。</p>
<h3 id="1431-相等运算符"><a class="markdownIt-Anchor" href="#1431-相等运算符"></a> 14.3.1 相等运算符</h3>
<p>相等运算符和不相等运算符中的一个应该把工作委托给另外一个。</p>
<h2 id="145-下标运算符"><a class="markdownIt-Anchor" href="#145-下标运算符"></a> 14.5 下标运算符</h2>
<p>如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。</p>
<h2 id="146-递增和递减运算符"><a class="markdownIt-Anchor" href="#146-递增和递减运算符"></a> 14.6 递增和递减运算符</h2>
<p><strong>定义前置递增/递减运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">StrBlobPtrS <span class="hljs-keyword">operator</span>++(); <span class="hljs-comment">// 前置运算符</span><br></code></pre></div></td></tr></table></figure>
<p><strong>区分前置和后置运算符</strong><br />
后置版本接受一个额外的（不被使用）int 类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为 0 的实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">StrBlobPtr <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>); <span class="hljs-comment">// 后置运算符</span><br></code></pre></div></td></tr></table></figure>
<p><strong>显式地调用后置运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">p.<span class="hljs-keyword">operator</span>++(<span class="hljs-number">0</span>); <span class="hljs-comment">// 调用后置版本的 operator++</span><br></code></pre></div></td></tr></table></figure>
<h2 id="147-成员访问运算符"><a class="markdownIt-Anchor" href="#147-成员访问运算符"></a> 14.7 成员访问运算符</h2>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrBlobPtr</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    std::strings <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    std::string* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> &#123; <span class="hljs-comment">// 将实际工作委托给解引用运算符 </span><br>        <span class="hljs-keyword">return</span> &amp; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">operator</span>*();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址。</p>
<p><strong>对箭头运算符返回值的限定</strong><br />
根据 point 类型的不同，point-&gt;mem 分别等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">(*point).mem; <span class="hljs-comment">// point 是一个内置的指针类型</span><br>point.<span class="hljs-built_in"><span class="hljs-keyword">operator</span></span>()-&gt;mem;	<span class="hljs-comment">// point 是类的一个对象</span><br></code></pre></div></td></tr></table></figure>
<p>如果 point 是定义了 operator-&gt; 的类的一个对象，则我们使用 point.operator-&gt;() 的结果来获取 mem。其中，如果该结果是一个指针，则执行 (*point).mem。如果该结果本身含有重载的 operator-&gt;()，则重复调用当前步骤。最终，当这一过程结束时程序或者返回了所需的内容，或者返回一些表示程序错误的信息。</p>
<h2 id="148-函数调用运算符"><a class="markdownIt-Anchor" href="#148-函数调用运算符"></a> 14.8 函数调用运算符</h2>
<p>可以像使用函数一样使用该类的对象。函数调用运算符必须是成员函数。如果类定义了调用运算符，则该类的对象称作函数对象。</p>
<h3 id="1481-lambda是函数对象"><a class="markdownIt-Anchor" href="#1481-lambda是函数对象"></a> 14.8.1 lambda是函数对象</h3>
<p>当我们编写了一个 lambda 后，编译器将该表达式翻译成一个未命名类的未命名对象，在lambda表达式产生的类中含有一个重载的函数调用运算符。</p>
<p><strong>表示 lambda 及相应捕获行为的类</strong><br />
当一个lambda 表达式通过引用捕获变量时，编译器可以直接使用该引用而无须在 lambda 产生的类中将其存储为数据成员。<br />
相反，通过值捕获的变量被拷贝到 lambda 中，这种类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。<br />
lambda 表达式产生的类不含默认构造函数、赋值运算符及默认析构函数。它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。</p>
<h3 id="1483-可调用对象与-function"><a class="markdownIt-Anchor" href="#1483-可调用对象与-function"></a> 14.8.3 可调用对象与 function</h3>
<p>两个不同类型的可调用对象却可能共享同一种调用形式。调用形式指明了调用返回的类型以及传递给调用的实参类型。</p>
<p><strong>标准库function类型</strong><br />
当创建一个具体的 function 类型时我们必须提供该 function 类型能够表示的对象的调用形式，如：<br />
<code>function&lt;int(int, int)&gt;</code><br />
function 类型重载了调用运算符，该运算符接受它自己的实参然后将其传递给存好的可调用对象:</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">map&lt;string, function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt;&gt; binops = &#123;<br>    &#123;<span class="hljs-string">&quot;*&quot;</span>, [](<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j) &#123; <span class="hljs-keyword">return</span> i * j; &#125;&#125;<br>&#125;<br>binops[<span class="hljs-string">&quot;*&quot;</span>](<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 调用 lambda 对象</span><br></code></pre></div></td></tr></table></figure>
<p><strong>重载的函数与 function</strong><br />
我们不能（直接）将重载函数的名字存入 function 类型的对象中，解决上述二义性问题的一条途径是存储函数指针，而非函数名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> i + j; &#125;<br><span class="hljs-function">Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data&amp;, <span class="hljs-keyword">const</span> Sales_data&amp;)</span></span>;<br>map&lt;string, function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt;&gt; binops;<br>binops.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;+&quot;</span>, add&#125;); <span class="hljs-comment">// 错误：哪个 add？</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*fp)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) = add; <span class="hljs-comment">// 指针所指的 add 是接受两个 int 的版本</span><br>binops.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;+&quot;</span>, fp&#125;); <span class="hljs-comment">// 正确</span><br></code></pre></div></td></tr></table></figure>
<h2 id="149-重载-类型转换与运算符"><a class="markdownIt-Anchor" href="#149-重载-类型转换与运算符"></a> 14.9 重载、类型转换与运算符</h2>
<p>转换构造函数和类型转换运算符共同定义了类类型转换。</p>
<h3 id="1491-类型转换运算符"><a class="markdownIt-Anchor" href="#1491-类型转换运算符"></a> 14.9.1 类型转换运算符</h3>
<p>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。<br />
<code>operator type() const;</code><br />
不允许转换成数组或者函数类型，但允许转换成指针或者引用类型。<br />
类型转换运算符既没有敁式的返回类型，也没有形参，而且必须定义成类的成员函数，一般被定义成 const 成员。</p>
<p><strong>显式的类型转换运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallInt</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//编译器不会自动执行这一类型转换</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span> <span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> val; &#125;<br>&#125;；<br>SmallInt si = <span class="hljs-number">1</span>;<br>si + <span class="hljs-number">3</span>; <span class="hljs-comment">// 错误：此处需要隐式的类型转换，但类的运算符是显式的</span><br><span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(si) + <span class="hljs-number">3</span>; <span class="hljs-comment">// 正确：显式地请求类型转换</span><br></code></pre></div></td></tr></table></figure>
<p>该规定存在一个例外，即如果表达式被用作条件，显式的类型转换将被隐式地执行。</p>
<h1 id="第十五章-面向对象程序设计"><a class="markdownIt-Anchor" href="#第十五章-面向对象程序设计"></a> 第十五章 面向对象程序设计</h1>
<h2 id="152-定义基类和派生类"><a class="markdownIt-Anchor" href="#152-定义基类和派生类"></a> 15.2 定义基类和派生类</h2>
<h3 id="1521-定义基类"><a class="markdownIt-Anchor" href="#1521-定义基类"></a> 15.2.1 定义基类</h3>
<p>基类通常都应该定义一个虚析构函数。</p>
<p><strong>成员函数与继承</strong><br />
关键字 virtual 只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</p>
<h3 id="1522-定义派生类"><a class="markdownIt-Anchor" href="#1522-定义派生类"></a> 15.2.2 定义派生类</h3>
<p><strong>派生类中的虚函数</strong><br />
派生类可以在它覆盖的函数前使用 virtual 关键字，但不是非得这么做。C++11 新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在后面添加一个关键字 override。</p>
<p><strong>派生类构造函数</strong><br />
派生类必须使用基类的构造函数来初始化它的基类部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-keyword">const</span> std::string&amp; book, <span class="hljs-keyword">double</span> p, std::<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc) :<br>    <span class="hljs-built_in">Quote</span>(book, p), <span class="hljs-built_in">min_qty</span>(qty), <span class="hljs-built_in">discount</span>(disc) &#123; &#125;<br>&#125;；<br></code></pre></div></td></tr></table></figure>
<p>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</p>
<p><strong>派生类使用基类的成员</strong><br />
派生类的作用域嵌套在基类的作用域之内。<br />
派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>
<p><strong>继承与静态成员</strong><br />
不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。</p>
<p><strong>派生类的声明</strong><br />
声明中包含类名但是不包含它的派生列表，派生列表以及与定义有关的其他细节必须与类的主体一起出现。</p>
<p><strong>被用作基类的类</strong><br />
如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。</p>
<p><strong>防止继承的发生</strong><br />
C++11 新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 final。</p>
<h3 id="1523-类型转换与继承"><a class="markdownIt-Anchor" href="#1523-类型转换与继承"></a> 15.2.3 类型转换与继承</h3>
<p><strong>静态类型与动态类型</strong><br />
动态类型直到运行时才可知。如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p>
<p><strong>不存在从基类向派生类的隐式类型转换……</strong><br />
如果我们己知某个基类向派生类的转换是安全的，则我们可以使用 static_cast 来强制覆盖掉编译器的检查工作。</p>
<p><strong>……在对象之间不存在类型转换</strong><br />
派生类向基类的自动类型转换只对指针或引用类型有效。<br />
当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p>
<h2 id="153-虚函数"><a class="markdownIt-Anchor" href="#153-虚函数"></a> 15.3 虚函数</h2>
<p>当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定，因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。</p>
<p><strong>对虚函数的调用可能在运行时才被解析</strong><br />
被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。</p>
<p><strong>派生类中的虚函数</strong><br />
一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。<br />
派生类中虚函数的返回类型必须与基类函数匹配。当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。</p>
<p><strong>final 和 override 说明符</strong><br />
派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。<br />
在 C++11 新标准中我们可以使用 override 关键字来说明派生类中的虚函数，使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误。<br />
final 和 override 说明符出现在形参列表以及尾置返冋类型之后。</p>
<p><strong>虚函数与默认实参</strong><br />
如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p>
<p><strong>回避虚函数的机制</strong><br />
在某些情况下，我们希望强制执行虚函数的某个特定版本，使用作用域运算符可以实现这一目的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> undiscounted = baseP-&gt;Quote::<span class="hljs-built_in">net_price</span>(<span class="hljs-number">42</span>);<br></code></pre></div></td></tr></table></figure>
<p>该代码强行调用 Quote 的 net_price 函数，而不管 baseP 实际指向的对象类型到底是什么。该调用将在编译时完成解析。</p>
<h2 id="154-抽象基类"><a class="markdownIt-Anchor" href="#154-抽象基类"></a> 15.4 抽象基类</h2>
<p><strong>纯虚函数</strong><br />
一个纯虚函数无须定义，我们通过在函数体的位置书写 =0 就可以将一个虚函数说明为纯虚函数。=0 只能出现在类内部的虚函数声明语句处。<br />
我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。</p>
<p><strong>含有纯虚函数的类是抽象基类</strong><br />
含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类。我们不能（直接）创建一个抽象基类的对象。</p>
<h2 id="155-访问控制与继承"><a class="markdownIt-Anchor" href="#155-访问控制与继承"></a> 15.5 访问控制与继承</h2>
<p>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</p>
<p><strong>公有、私有和受保护继承</strong><br />
派生类访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。派生类访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限，以及继承自派生类的新类的访问权限。</p>
<p><strong>派生类向基类转换的可访问性</strong><br />
假定 D 继承自 B：</p>
<ul>
<li>只有当 D 公有地继承 В 时，用户代码才能使用派生类向基类的转换。</li>
<li>不论 D 以什么方式继承 B, D 的成员函数和友元都能使用派生类向基类的转换。</li>
<li>如果 D 继承 В 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 В 的类型转换。</li>
</ul>
<p><strong>友元与继承</strong><br />
友元关系同样也不能继承， 基类的友元在访问派生类成员时不具有特殊性。<br />
对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此。</p>
<p><strong>改变个别成员的可访问性</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">protected</span>:<br>    std::<span class="hljs-keyword">size_t</span> n;<br>&#125;；<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">private</span> Base &#123; <span class="hljs-comment">// 注意：private 继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::n;<br>&#125;；<br></code></pre></div></td></tr></table></figure>
<p>using 声明语句中名字的访问权限由该 using 声明语句之前的访问说明符来决定。<br />
using 只影响派生类的使用者对基类成员的访问权限，派生类只能为那些它可以访问的名字提供 using 声明。</p>
<h2 id="156-继承中的类作用域"><a class="markdownIt-Anchor" href="#156-继承中的类作用域"></a> 15.6 继承中的类作用域</h2>
<p>派生类的作用域嵌套在其基类的作用域之内，如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。</p>
<p><strong>在编译时进行名字查找</strong><br />
一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。不能通过基类对象/指针/引用（静态类型）调用派生类（动态类型）独有的成员。</p>
<p><strong>名字冲突与继承</strong><br />
定义在内层作用域的名字将隐藏定义在外层作用域的名字。</p>
<p><strong>通过作用域运算符来使用隐藏的成员</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span> :</span> Base &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_base_mem</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Base::mem; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>作用域运算符将覆盖掉原有的查找规则，并指示编译器从 Base 类的作用域开始查找 men。</p>
<p><strong>名字查找先于类型检查</strong></p>
<p><strong>覆盖重载的函数</strong><br />
如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。<br />
一种好的解决方案是为重载的成员提供一条 using 声明语句。using 声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的 using 声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了。</p>
<h2 id="157-构造函数与拷贝控制"><a class="markdownIt-Anchor" href="#157-构造函数与拷贝控制"></a> 15.7 构造函数与拷贝控制</h2>
<h3 id="1571虚析构函数"><a class="markdownIt-Anchor" href="#1571虚析构函数"></a> 15.7.1虚析构函数</h3>
<p>我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。<br />
一个基类总是需要析构函数，而且它能将析构函数设定为虚函数，但是无法由此推断该基类还需要赋值运算符或拷贝构造函数。</p>
<p><strong>虚析构函数将阻止合成移动操作</strong><br />
如果一个类定义了析构函数，即使它通过 =default 的形式使用了合成的版本，编译器也不会为这个类合成移动操作。</p>
<h3 id="1572-合成拷贝控制与继承"><a class="markdownIt-Anchor" href="#1572-合成拷贝控制与继承"></a> 15.7.2 合成拷贝控制与继承</h3>
<p><strong>派生类中删除的拷贝控制与基类的关系</strong></p>
<ul>
<li>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的。</li>
<li>如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的。</li>
</ul>
<h3 id="1573-派生类的拷贝控制成员"><a class="markdownIt-Anchor" href="#1573-派生类的拷贝控制成员"></a> 15.7.3 派生类的拷贝控制成员</h3>
<p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。<br />
析构函数只负责销毁派生类自己分配的资源。</p>
<p><strong>定义派生类的拷贝或移动构造函数</strong><br />
当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span> <span class="hljs-comment">/*...*/</span> &#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>:</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认情况下，基类的默认构造函数初始化对象的基类部分</span><br>    <span class="hljs-comment">// 要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中显式地调用该构造函数</span><br>    <span class="hljs-built_in">D</span>(<span class="hljs-keyword">const</span> D&amp; d) : <span class="hljs-built_in">Base</span>(d)	&#123;&#125; <span class="hljs-comment">// 拷贝基类成员</span><br>    <span class="hljs-built_in">D</span>(D&amp;&amp; d) : <span class="hljs-built_in">Base</span>(std::<span class="hljs-built_in">move</span>(d)) &#123;&#125; <span class="hljs-comment">// 移动基类成员</span><br>&#125;；<br></code></pre></div></td></tr></table></figure>
<p>如果我们想拷贝或移动基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷或移动构造函数。</p>
<p><strong>派生类赋值运算符</strong><br />
与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">D &amp;D::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> D &amp;rhs) &#123;<br>    Base::<span class="hljs-keyword">operator</span>=(rhs); <span class="hljs-comment">// 为基类部分賦值</span><br>    <span class="hljs-comment">// 按照过去的方式为派生类的成员赋值，酌情处理自赋值及释放已有资源等情况</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>在构造函数和析构函数中调用虚函数</strong><br />
当执行基类的构造函数时，该对象的派生类部分是未被初始化的状态。销毁派生类对象的次序正好相反，当执行基类的析构函数时，派生类部分已经被销毁掉了。<br />
如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</p>
<h3 id="1574-继承的构造函数"><a class="markdownIt-Anchor" href="#1574-继承的构造函数"></a> 15.7.4 继承的构造函数</h3>
<p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的 using 声明语句。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Disc_quote &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Disc_quote::Disc_quote; <span class="hljs-comment">// 继承 Disc_quote 的构造函数</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。在我们的 Bulk_quote 类中，继承的构造函数等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-keyword">const</span> std::strings book, <span class="hljs-keyword">double</span> price, std::<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc):<br>    <span class="hljs-built_in">Disc_quote</span>(book, price, qty, disc) &#123; &#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>继承的构造函数的特点</strong><br />
一个构造函数的 using 声明不会改变该构造函数的访问级别。一个 using 声明语句不能指定 explicit 或 constexpr。如果基类的构造函数是 explicit 或者 constexpr，则继承的构造函数也拥有相同的属性。<br />
当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分別省略掉一个含有默认实参的形参。<br />
如果派生类定义的构造函数与基类的构造函数具有相问的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。<br />
默认、拷贝和移动构造函数不会被继承。如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。</p>
<h2 id="158-容器与继承"><a class="markdownIt-Anchor" href="#158-容器与继承"></a> 15.8 容器与继承</h2>
<p>当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容。</p>
<p><strong>在容器中放置（智能）指针而非对象</strong><br />
当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针。</p>
<h1 id="第十六章-模板与泛型编程"><a class="markdownIt-Anchor" href="#第十六章-模板与泛型编程"></a> 第十六章 模板与泛型编程</h1>
<h2 id="161-定义模板"><a class="markdownIt-Anchor" href="#161-定义模板"></a> 16.1 定义模板</h2>
<h3 id="1611-函数模板"><a class="markdownIt-Anchor" href="#1611-函数模板"></a> 16.1.1 函数模板</h3>
<p><strong>模板类型参数</strong><br />
类型参数前必须使用关键字 class 或 typename</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">U</span>&gt;</span> <span class="hljs-built_in">calc</span> (<span class="hljs-keyword">const</span> T&amp;, <span class="hljs-keyword">const</span> U&amp;);<br><span class="hljs-comment">// 正确：在模板参数列表中，typename 和 class 没有什么不同</span><br></code></pre></div></td></tr></table></figure>
<p><strong>非类型模板参数</strong><br />
当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">unsigned</span> N, <span class="hljs-keyword">unsigned</span> M&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> (&amp;pl)[N], <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> (&amp;p2)[M])</span></span><br><span class="hljs-function">        <span class="hljs-keyword">return</span> <span class="hljs-title">strcrap</span><span class="hljs-params">(p1, p2)</span></span>;<br>    &#125;<br></code></pre></div></td></tr></table></figure>
<p>当我们调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;mom&quot;</span>)<br></code></pre></div></td></tr></table></figure>
<p>时，编译器会使用字面常量的大小来代替 N 和 M，从而实例化模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> (&amp;pl)[<span class="hljs-number">3</span>], <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> (&amp;p2)[<span class="hljs-number">4</span>])</span></span><br></code></pre></div></td></tr></table></figure>
<p>一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。针参数也可以用 nullptr 或一个值为 0 的常量表达式来实例化。</p>
<p><strong>模板编译</strong><br />
编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。<br />
函数模板和类模板成员函数的定义通常放在头文件中。</p>
<p><strong>大多数编译错误在实例化期间报告</strong><br />
通常，编译器会在三个阶段报告错误：</p>
<ul>
<li>第一个阶段是编译模板本身时。在这个阶段编译器可以检查语法错误。</li>
<li>第二个阶段是编译器遇到模板使用时。在此阶段编译器通常会检查实参数目是否正确，它还能检查参数类型是否匹配。</li>
<li>第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。</li>
</ul>
<h3 id="1612-类模板"><a class="markdownIt-Anchor" href="#1612-类模板"></a> 16.1.2 类模板</h3>
<p>编译器不能为类模板推断模板参数类型。</p>
<p><strong>实例化类模板</strong><br />
一个类模板的每个实例都形成一个独立的类。类型<code>Blob&lt;string&gt;</code>与任何其他 Blob 类型都没有关联。</p>
<p><strong>在模板作用域中引用模板类型</strong><br />
类模板的名字不是一个类型名，类模板用来实例化类型，而一个实例化的类型总是包含模板参数的。</p>
<p><strong>类模板的成员函数</strong><br />
定义在类模板之外的成员函数就必须以关键字 template 开始，后接类模板参数列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    ret_type class_name&lt;T&gt;::<span class="hljs-built_in">member_name</span>(parm_list)<br></code></pre></div></td></tr></table></figure>
<p><strong>类模板成员函数的实例化</strong><br />
对于一个实例化了的类模板，其成员只有在使用时才被实例化。</p>
<p><strong>在类代码内简化模板类名的使用</strong><br />
当我们使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，我们可以直接使用模板名而不提供实参。</p>
<p><strong>一对一友好关系</strong><br />
类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlobPtr</span>;</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blob</span> &#123;</span><br>    <span class="hljs-comment">//每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlobPtr</span>&lt;</span>T&gt;;<br>&#125;;<br><br>Blob&lt;<span class="hljs-keyword">char</span>&gt; ca; <span class="hljs-comment">// BlobPtr&lt;char&gt; 是本对象的友元</span><br></code></pre></div></td></tr></table></figure>
<p>BlobPtr<char> 的成员可以访问任何其他 Blob<char> 对象的非 public 部分，但 ca 对 Blob 的任何其他实例都没有特殊访问权限。</p>
<p><strong>通用和特定的模板友好关系</strong><br />
一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 前置声明，在将模板的一个特定实例声明为友元时要用到</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &#123;</span> <span class="hljs-comment">// C 是一个普通的非模板类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal</span>&lt;</span>C&gt;; <span class="hljs-comment">// 用类 C 实例化的 Pal 是 C 的一个友元</span><br>    <span class="hljs-comment">// Ра12 的所有实例都是 С 的友元，这种情况无须前置声明</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal2</span>;</span><br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C2</span> &#123;</span> <span class="hljs-comment">// C2 本身是一个类模板</span><br>    <span class="hljs-comment">// C2 的每个实例将相同实例化的 Pal 声明为友元</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal</span>&lt;</span>T&gt;; <span class="hljs-comment">// Pal 的模板声明必须在作用域之内</span><br>    <span class="hljs-comment">// Pal2 的所有实例都是 C2 的每个实例的友元，不需要前置声明</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X&gt; <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal2</span>;</span><br>    <span class="hljs-comment">// Pal3 是一个非模板类，它是 C2 所有实例的友元</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal3</span>;</span> <span class="hljs-comment">// 不需要 Pal3 的前置声明</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><strong>令模板自己的类型参数成为友元</strong><br />
我们可以将模板类型参数声明为友元：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> &#123;</span><br>    <span class="hljs-keyword">friend</span> Type; <span class="hljs-comment">// 将访问权限授予用来实例化Bar的类型</span><br>    <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>对于某个类型名 Name，Name 将成为 Bar<name> 的友元。</p>
<p><strong>模板类型别名</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> Blob&lt;string&gt; StrBlob;<br></code></pre></div></td></tr></table></figure>
<p>新标准允许我们为类模板定义一个类型别名:</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> twin = pair&lt;T, T&gt;;<br>twin&lt;string&gt; authors; <span class="hljs-comment">// authors 是一个 pair&lt;string, string&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>当我们定义一个模板类型别名时，可以固定一个或多个模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> partNo = pair&lt;T, <span class="hljs-keyword">unsigned</span>&gt;;<br>partNo&lt;string&gt; books; <span class="hljs-comment">// books 是一个 pair&lt;string, unsigned&gt;</span><br></code></pre></div></td></tr></table></figure>
<p><strong>类模板的 static 成员</strong><br />
每个实例都有其自己的 static 成员实例。<br />
模板类的每个static 数据成员必须有且仅有一个定义。但是，类模板的每个实例都有一个独有的 static 对象。因此，与定义模板的成员函数类似，我们将 static 数据成员也定义为模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义并初始化 ctr</span><br></code></pre></div></td></tr></table></figure>
<p>为了通过类来直接访问 static 成员，我们必须引用一个特定的实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Foo&lt;<span class="hljs-keyword">int</span>&gt; fi; <br><span class="hljs-keyword">auto</span> ct = Foo&lt;<span class="hljs-keyword">int</span>&gt;::<span class="hljs-built_in">count</span>(); <span class="hljs-comment">// 实例化 Foo&lt;int&gt;::count</span><br>ct = fi.<span class="hljs-built_in">count</span>(); <span class="hljs-comment">// 使用 Foo&lt;int&gt;::count</span><br>ct = Foo::<span class="hljs-built_in">count</span>(); <span class="hljs-comment">// 错误</span><br></code></pre></div></td></tr></table></figure>
<h3 id="1613-模板参数"><a class="markdownIt-Anchor" href="#1613-模板参数"></a> 16.1.3 模板参数</h3>
<p>我们通常将类型参数命名为 T，但实际上我们可以使用任何名字。</p>
<p><strong>模板参数与作用域</strong><br />
模板参数会隐藏外层作用域中声明的相同名字。但是在模板内不能重用模板参数名。</p>
<p><strong>模板声明</strong><br />
声明中的模板参数的名字不必与定义中相同。<br />
一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</p>
<p><strong>使用类的类型成员</strong><br />
假定 T 是一个模板类型参数，当编译器遇到类似 T::mem 这样的代码时，它不会知道 mem 是一个类型成员还是一个 static 数据成员，直至实例化时才会知道。<br />
默认情况下，C++ 假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型，通过使用关键字 typename 来实现这一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">typename</span> T::value_type <span class="hljs-title">top</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typename</span> T::<span class="hljs-built_in">value_type</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>当我们希望通知编译器一个名字表示类型时，必须使用关键字 typename，而不能使用 class。</p>
<p><strong>默认模板实参</strong><br />
与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时, 它才可以有默认实参。</p>
<p><strong>模板默认实参与类模板</strong><br />
如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对。</p>
<h3 id="1614-成员模板"><a class="markdownIt-Anchor" href="#1614-成员模板"></a> 16.1.4 成员模板</h3>
<p>成员模板不能是虚函数。</p>
<p><strong>类模板的成员模板</strong><br />
当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 类的类型参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt; <span class="hljs-comment">// 构造函数的类型参數</span><br>    Blob&lt;T&gt;::<span class="hljs-built_in">Blob</span>(It b, It e) :<br>        <span class="hljs-built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e)) &#123; &#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="1615-控制实例化"><a class="markdownIt-Anchor" href="#1615-控制实例化"></a> 16.1.5 控制实例化</h3>
<p>在多个文件中实例化相同模板的额外开销可能非常严重，我们可以通过显式实例化来避免这种开销。<br />
当编译器遇到 extern 模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为 extern 就表示承诺在程序其他位置有该实例化的一个非 extern 声明（定义）。对于一个给定的实例化版本，可能有多个 extern 声明，但必须只有一个定义。extern 声明必须出现在任何使 用此实例化版本的代码之前。<br />
实例化文件必须为每个在其他文件中声明为 extern 的类型和函数提供一个（非extern）的定义。<br />
当编译器遇到一个实例化定义时，它为其生成代码。<br />
实例化定义会实例化所有成员。</p>
<h3 id="1622-函数模板显式实参"><a class="markdownIt-Anchor" href="#1622-函数模板显式实参"></a> 16.2.2 函数模板显式实参</h3>
<p><strong>指定显式模板实参</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 编译器无法推断T1，它未出现在函数参数列表中</span><br><span class="hljs-keyword">template</span> &lt;typeпаше Tl, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3&gt;<br><span class="hljs-function">T1 <span class="hljs-title">sum</span><span class="hljs-params">(T2, T3)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>没有任何函数实参的类型可用米推断 Tl 的类型。毎次调用 sum 时调用者都必须为 T1 提供一个显式模板实参:</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// T1 是显式指定的，T2 和 T3 是从函数实参类型推断而来的</span><br><span class="hljs-keyword">auto</span> val3 = sum&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(i, lng); <span class="hljs-comment">// long long sum(int, long)</span><br></code></pre></div></td></tr></table></figure>
<p>显式模板实参按由左至右的顺序与对应的模板参数匹配，只有尾部（最右）参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数推断出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 糟糕的设计：用户必须指定所有三个模板参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tl, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3&gt;<br><span class="hljs-function">T3 <span class="hljs-title">alternative_sum</span><span class="hljs-params">(T2, Tl)</span></span>;<br><span class="hljs-keyword">auto</span> val2 = alternative_sum&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">long</span>&gt;(i, lng);<br></code></pre></div></td></tr></table></figure>
<p><strong>正常类型转换应用于显式指定的实参</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">long</span> lng;<br><span class="hljs-built_in">compare</span> (lng, <span class="hljs-number">1024</span>); <span class="hljs-comment">// 错误：模板参数不匹配</span><br>compare&lt;<span class="hljs-keyword">long</span>&gt; (lng, <span class="hljs-number">1024</span>); <span class="hljs-comment">// 正确：实例化 compare (long, long)</span><br>compare&lt;<span class="hljs-keyword">int</span>&gt; (lng, <span class="hljs-number">1024</span>); <span class="hljs-comment">// 正确：实例化 compare (int, int)</span><br></code></pre></div></td></tr></table></figure>
<h3 id="1623-尾置返回类型与类型转换"><a class="markdownIt-Anchor" href="#1623-尾置返回类型与类型转换"></a> 16.2.3 尾置返回类型与类型转换</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br>??? &amp;<span class="hljs-built_in">fcn</span>(It beg, It end) &#123;<br>    <span class="hljs-keyword">return</span> *beg; <span class="hljs-comment">// 返回序列中一个元素的引用</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在编译器遇到函数的参数列表之前，beg 都是不存在的。为了定义此函数，我们必须使用尾置返回类型。由于尾置返回出现在参 M 数列表之后，它可以使用函数的参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 尾置返回允许我们在参数列表之后声明返回类型</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fcn</span> <span class="hljs-params">(It beg, It end)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(*beg)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> *beg; <span class="hljs-comment">// 返回序列中一个元素的引用</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>进行类型转换的标准库模板类</strong><br />
为了获得兀素类型，我们可以使用标准库的类型转换模板。remove_reference 模板有一个模板类型参数和一个名为 type 的 public 类型成员。如果我们用一个引用类型实例化 remove_reference，则 type 将表示被引用的类型。<br />
<code>decltype(*beg)</code>返回元素类型的引用类型。<code>remove_reference::type</code>脱去引用，剩下元素类型本身。<br />
组合使用 remove_reference、尾置返冋及 decltype，我们就可以在函数中返回元素值的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 为了使用模板参数的成员，必须用 typename</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fcn2</span><span class="hljs-params">(It beg, It end)</span>-&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">typename</span> remove_reference&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(*beg)</span>&gt;::type </span>&#123;<br>        <span class="hljs-keyword">return</span> *beg; <span class="hljs-comment">// 返回序列中一个元素的拷贝</span><br>    &#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="1624-函数指针和实参推断"><a class="markdownIt-Anchor" href="#1624-函数指针和实参推断"></a> 16.2.4 函数指针和实参推断</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp;, <span class="hljs-keyword">const</span> T&amp;)</span></span>;<br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*pfl)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;) = compare;<br><span class="hljs-comment">// pfl 指向实例 int compare (const int&amp;, const int&amp;)</span><br></code></pre></div></td></tr></table></figure>
<p>pfl 中参数的类型决定了 T 的模板实参的类型。在本例中，T 的模板实参类型为 int。指针 pfl 指向 compare 的 int 版本实例。<br />
当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数，能唯一确定其类型或值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// func 的重载版本，每个版本接受一个不同的函数指针类型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>(*)(<span class="hljs-keyword">const</span> strings, <span class="hljs-keyword">const</span> strings))</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>(*)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;))</span></span>;<br><span class="hljs-built_in">func</span>(compare); <span class="hljs-comment">// 错误：使用 compare 的哪个实例？</span><br><span class="hljs-built_in">func</span>(compare&lt;<span class="hljs-keyword">int</span>&gt;); <span class="hljs-comment">// 正确：显式指出实例化哪个 compare 版本</span><br><span class="hljs-comment">// 传递 compare (const int&amp;, const int&amp;)</span><br></code></pre></div></td></tr></table></figure>
<h3 id="1625-模板实参推断和引用"><a class="markdownIt-Anchor" href="#1625-模板实参推断和引用"></a> 16.2.5 模板实参推断和引用</h3>
<p><strong>从左值引用函数参数推断类型</strong><br />
当一个函数参数是模板类型参数的一个普通（左值）引用时，只能传递给它一个左值，如果实参是 const 的，则 T 将被推断为 const 类型。<br />
如果一个函数参数的类型是 const T&amp;，当函数参数本身是 const 时，T 的类型推断的结果不会是一个 const 类型。</p>
<p><strong>引用折叠和右值引用参数</strong><br />
当我们将一个左值（i）传递给函数的右值引用参数，且此右值引用指向模板类型参数（T&amp;&amp;）时，编译器推断模板类型参数为实参的左值引用类型。因此，当我们调用 f3(i) 时，编译器推断 T 的类型为 int&amp;，而非 int。<br />
这好像意味着 f3 的函数参数应该是一个类型 int&amp; 的右值引用。通常，我们不能（直接）定义一个引用的引用。但是，通过类型别名或通过模板类型参数间接定义是可以的。<br />
如果我们间接创建一个引用的引用，则这些引用形成了“折叠”。除了右值引用的右值引用会折叠为一个右值引用，其余情况都会折叠为一个普通的左值引用类型。<br />
这两个规则暗示，我们可以将任意类型的实参传递给 T&amp;&amp; 类型的函数参数。</p>
<h3 id="1626-理解-stdmove"><a class="markdownIt-Anchor" href="#1626-理解-stdmove"></a> 16.2.6 理解 std::move</h3>
<p><strong>从一个左值 static_cast 到一个右值引用是允许的</strong><br />
可以用 static_cast 显式地将一个左值转换为一个右值引用。</p>
<h3 id="1627-转发"><a class="markdownIt-Anchor" href="#1627-转发"></a> 16.2.7 转发</h3>
<p><strong>定义能保持类型信息的函数参数</strong><br />
如果一个函数参数是指向模板类型参数的右值引用（如T&amp;&amp;），它对应的实参的 const 属性和左值/右值属性将得到保持。</p>
<p><strong>在调用中使用 std::forward 保持类型信息</strong><br />
forward 返回该显式实参类型的右值引用即，forward<T> 的返回类型是 T&amp;&amp;。通过其返回类型上的引用折叠，forward 可以保持给定实参的左值/右值属性。<br />
当用于一个指向模板参数类型的右值引用函数参数（T&amp;&amp;）时，forward 会保持实参类型的所有细节。</p>
<h2 id="164-可变参数模板"><a class="markdownIt-Anchor" href="#164-可变参数模板"></a> 16.4 可变参数模板</h2>
<p>可变数量的参数被称为参数包，我们用一个省略号来指出一个模板参数或函数参数表示一个包。<br />
在一个模板参数列表中，class… 或 typename… 指出接下来的参数表示零个或多个类型的列表。一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Args 是一个模板参数包，rest 是一个函数参数包</span><br><span class="hljs-comment">// Args 表示零个或多个模板类型参数</span><br><span class="hljs-comment">// rest 表示零个或多个函数参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;t, <span class="hljs-keyword">const</span> Args&amp; ... rest)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p><strong>sizeof… 运算符</strong><br />
当我们需要知道包中有多少元素时，可以使用 sizeof… 运算符。sizeof…返回一个常量表达式，而且不会对其实参求值。</p>
<h3 id="1641-编写可变参数函数模板"><a class="markdownIt-Anchor" href="#1641-编写可变参数函数模板"></a> 16.4.1 编写可变参数函数模板</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-keyword">const</span> T &amp;t, <span class="hljs-keyword">const</span> Args&amp;... rest)</span> </span>&#123;<br>    os « t « <span class="hljs-string">&quot;, &quot;</span>；	<span class="hljs-comment">// 打印第一个实参</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span> (os, rest...);	<span class="hljs-comment">// 递归调用，打印其他实参</span><br>)<br></code></pre></div></td></tr></table></figure>
<p>rest 中的第一个实参被绑定到 t，剩余实参形成下一个 print 调用的参数包。</p>
<h3 id="1642-包扩展"><a class="markdownIt-Anchor" href="#1642-包扩展"></a> 16.4.2 包扩展</h3>
<p>当扩展一个包时，我们还要提供用于每个扩展元素的模式。扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。我们通过在模式右边放一个省略号来触发扩展操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-keyword">const</span> T &amp;t, <span class="hljs-keyword">const</span> Args&amp;... rest)</span> </span>&#123; <span class="hljs-comment">// 扩展 Args</span><br>    os « t &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(os, rest...);	<span class="hljs-comment">// 扩展 rest</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对 Args 的扩展中，编译器将模式 const Arg&amp; 应用到模板参数包 Args 中的每个元素。因此，此模式的扩展结果是一个逗号分隔的零个或多个类型的列表，每个类型都形如 const type&amp;。<br />
第二个扩展发生在对 print 的调用中。在此情况下，模式是函数参数包的名字（即 rest)。此模式扩展出一个由包中元素组成的、逗号分隔的列表。因此，这个调用等价于：</p>
<p><strong>理解包扩展</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(os, <span class="hljs-built_in">debug_rep</span>(rest)...);<br></code></pre></div></td></tr></table></figure>
<p>这个 print 调用使用了模式 debug_reg(rest)。此模式表示我们希望对函数参数包 rest 中的每个元素调用 debug_rep。扩展结果将是一个逗号分隔的 debug_rep 调用列表。即，下面调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">errorMsg</span>(cerr, fcnName, code.<span class="hljs-built_in">num</span>(), otherData, <span class="hljs-string">&quot;other&quot;</span>, item);<br></code></pre></div></td></tr></table></figure>
<p>就好像我们这样编写代码一样</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">print</span> (cerr, <span class="hljs-built_in">debug_rep</span>(fcnName), <span class="hljs-built_in">debug_rep</span>(code.<span class="hljs-built_in">num</span>()),<br>    <span class="hljs-built_in">debug_rep</span>(otherData), <span class="hljs-built_in">debug_rep</span>(<span class="hljs-string">&quot;otherData&quot;</span>), <span class="hljs-built_in">debug_rep</span>(item));<br></code></pre></div></td></tr></table></figure>
<h2 id="165-模板特例化"><a class="markdownIt-Anchor" href="#165-模板特例化"></a> 16.5 模板特例化</h2>
<p>一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。</p>
<p><strong>定义函数模板特例化</strong><br />
当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。为了指出我们正在实例化一个模板，应使用关键字 template 后跟一个空尖括号对，指出我们将为原模板的所有模板参数提供实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// compare 的特殊版本，处理字符数组的指针</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> &amp;pl, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> &amp;p2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(pi, p2);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>函数重载与模板特例化</strong><br />
当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模板的一个特殊实例提供了定义。一个特例化版本本质上是一个实例，而非函数名的一个重载版本。<br />
特例化不影响函数匹配。<br />
为了特例化一个模板，原模板的声明必须在作用域中。而且，在任何使用模扳实例的代码之前，特例化版本的声明也必须在作用域中。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/CPP/">CPP</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/24/Leet/">
                        <span class="hidden-mobile">LeetCode 刷题记录</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"5e2153d92606f0f30050","clientSecret":"71138048e7eacddcadcf14ce72f87fe12fa35c40","repo":"Hinageshi01.github.io","owner":"Hinageshi01","admin":["Hinageshi01"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'e7a00a927c8207fa994ef5645407d408'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <br/> 本站内容依据 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> 许可证进行授权 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.css" />
  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
