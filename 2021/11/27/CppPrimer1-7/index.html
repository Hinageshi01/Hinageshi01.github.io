

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;dark&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Hinageshi">
  <meta name="keywords" content="">
  
  <title>笔记 C++ Primer 第一章~第七章 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":25,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["_slim",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":17057737,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Hinageshi的駄菓子屋</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archive
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/backGround.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="笔记 C++ Primer 第一章~第七章">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-27 00:08" pubdate>
        November 27, 2021
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      88
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">笔记 C++ Primer 第一章~第七章</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：December 15, 2021
                
              </p>
            
            <div class="markdown-body">
              <h1 id="序言"><a class="markdownIt-Anchor" href="#序言"></a> 序言</h1>
<p>  《C++ Primer 5th Edition》前七章的读书笔记，只记录我认为重要/不熟悉的知识点，前七章刚好都属于不那么“C++”的部分，比较适合作为一个整理的节点。</p>
<h1 id="第一章-开始"><a class="markdownIt-Anchor" href="#第一章-开始"></a> 第一章 开始</h1>
<h2 id="12-初识输入输出"><a class="markdownIt-Anchor" href="#12-初识输入输出"></a> 1.2 初识输入输出</h2>
<p><code>#include &lt;iostream&gt;</code><br />
使用了 iostream 库，包含了 istream 类和 ostream 类，分别表示输入流和输出流。</p>
<p><strong>向流写入数据</strong><br />
输出运算符（&lt;&lt;）接受两个运算对象，左侧必须是一个 ostream 对象，右侧是要打印的值，然后返回其左侧的对象。<br />
<code>std::endl</code><br />
这是一个被称为操作符的特殊值，写入 endl 的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。调试时应保证一直刷新流，避免程序崩溃时输出还留在缓冲区中。<br />
<code>std::cerr</code><br />
一个 ostream 对象，写到 cerr 的数据是不缓冲的。<br />
<code>std::clog</code><br />
一个 ostream 对象，写到 clog 的数据是被缓冲的。</p>
<p><strong>从流读取数据</strong><br />
输入运算符（&gt;&gt;）接受两个运算对象，左侧必须是一个 istream 对象，右侧是要接收值的对象，然后返回其左侧的对象。</p>
<h2 id="14-控制流"><a class="markdownIt-Anchor" href="#14-控制流"></a> 1.4 控制流</h2>
<h3 id="143-读取数量不定的输入数据"><a class="markdownIt-Anchor" href="#143-读取数量不定的输入数据"></a> 1.4.3 读取数量不定的输入数据</h3>
<p><code>while(std::cin &gt;&gt; value)</code><br />
当我们使用一个 istream 对象作为条件时，其效果是检测流的状态。当遇到文件结束符，或遇到无效输入时，istream 对象的状态会变为无效。</p>
<h1 id="第二章-变量和基本类型"><a class="markdownIt-Anchor" href="#第二章-变量和基本类型"></a> 第二章 变量和基本类型</h1>
<h2 id="21-基本内置类型"><a class="markdownIt-Anchor" href="#21-基本内置类型"></a> 2.1 基本内置类型</h2>
<h3 id="211-算术类型"><a class="markdownIt-Anchor" href="#211-算术类型"></a> 2.1.1 算术类型</h3>
<p><strong>带符号类型和无符号类型</strong><br />
尽管字符型有三种<code>char</code>、<code>signed char</code>、<code>unsigned char</code>，字符的表现形式却只有两种：类型<code>char</code>实际上会表现为另两种的一种，具体是否带符号由编译器决定，所以使用字符型进行运算特别容易出问题。</p>
<h3 id="212-类型转换"><a class="markdownIt-Anchor" href="#212-类型转换"></a> 2.1.2 类型转换</h3>
<p>无符号超范围时取模，有符号超范围时结果未定义。<br />
<strong>含有无符号类型的表达式</strong><br />
当一个表达式里既有带符号数又有无符号数时，带符号数会自动转换成无符号数时。这个过程相当于将一个带符号数直接赋给成无符号变量，那么当带符号数为负时就会出现异常的结果。</p>
<h3 id="213-字面值查常量"><a class="markdownIt-Anchor" href="#213-字面值查常量"></a> 2.1.3 字面值查常量</h3>
<p><strong>字符字面值和字串符字面值</strong><br />
字符串字面值的类型实际上是由常量字符构成的数组。编译器在每个字符串的结尾处添加一个空字符(’\0’)，因此，字符串字面值的实际长度要比它的内容多1。<br />
如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一 个整体。</p>
<h2 id="22-变量"><a class="markdownIt-Anchor" href="#22-变量"></a> 2.2 变量</h2>
<h3 id="221-变量定义"><a class="markdownIt-Anchor" href="#221-变量定义"></a> 2.2.1 变量定义</h3>
<p><strong>默认初始化</strong><br />
定义于任何函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量将不被初始化。string 类规定如果没有指定初值则生成一个空串。</p>
<h3 id="222-变量声明和定义的关系"><a class="markdownIt-Anchor" href="#222-变量声明和定义的关系"></a> 2.2.2 变量声明和定义的关系</h3>
<p>声明使得名字为程序所知。而定义负责创建与名字关联的实体。变量声明规定了变量的类型和名字。定义还申请存储空间，也可能会为变量赋一个初始值。<br />
<strong>extern</strong><br />
如果想声明一个变量而非定义它，就在变量名前添加关键字 extern，而且不要显式地初始化变量。extern 语句如果包含初始值就不再是声明，而变成定义了。变量能且只能被定义一次，但是可以被多次声明。<br />
如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p>
<h2 id="23-复合类型"><a class="markdownIt-Anchor" href="#23-复合类型"></a> 2.3 复合类型</h2>
<h3 id="231-引用"><a class="markdownIt-Anchor" href="#231-引用"></a> 2.3.1 引用</h3>
<p>因为无法令引用重新绑定到另外一个对象，因此引用必须初始化为一个对象。因为引用本身不是一个对象，所以不能定义引用的引用。</p>
<h2 id="24-const-限定符"><a class="markdownIt-Anchor" href="#24-const-限定符"></a> 2.4 const 限定符</h2>
<h3 id="241-const-的引用"><a class="markdownIt-Anchor" href="#241-const-的引用"></a> 2.4.1 const 的引用</h3>
<p>所谓常量引用是对常量的引用，因为引用不是一个对象，所以不存在常量引用。在初始化常量引用时允许用任意表达式作为初始值，此时该引用会绑定到一个临时量对象（常量）上，而与原本等号右侧的表达式几乎不相关。</p>
<h3 id="242-指针和-const"><a class="markdownIt-Anchor" href="#242-指针和-const"></a> 2.4.2 指针和 const</h3>
<p>允许一个指向常量的指针指向一个非常量对象，所谓的底层 const，不过是指针或引用自己认为自己指向了常量，然后自觉地不去改变所指对象的值。</p>
<h3 id="243-顶层-const"><a class="markdownIt-Anchor" href="#243-顶层-const"></a> 2.4.3 顶层 const</h3>
<p>用于声明引用的 const 都是底层 const。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。</p>
<h3 id="244-constexpr-表达式"><a class="markdownIt-Anchor" href="#244-constexpr-表达式"></a> 2.4.4 constexpr 表达式</h3>
<p>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。显然字面值属于常量表达式，用常量表达式初始化的 const 对象也是常量表达式。<br />
将变量声明为 constexpr 类型以便由编译器来验证变量的值是否是一个常量表达式。<br />
<strong>字面值类型</strong><br />
算术类型、引用和指针都属于字面值类型。一个 constexpr 指针的初始值必须是 nullptг 或者 0，或者是存储于某个固定地址中的对象（定义于所有函数体之外的变量）。<br />
<strong>指针和 constexpr</strong><br />
在 constexpr 声明中如果定义了一个指针，无论限定符 constexpr 出现在什么位置，都仅对指针生效，与指针所指的对象无关。</p>
<h2 id="25-处理类型"><a class="markdownIt-Anchor" href="#25-处理类型"></a> 2.5 处理类型</h2>
<h3 id="251-类型别名"><a class="markdownIt-Anchor" href="#251-类型别名"></a> 2.5.1 类型别名</h3>
<p>使用<code>typedef char *pstr;</code>或<code>using pstr = char *;</code><br />
注意<code>const pstr cstr</code>不等于<code>const char *cstr</code>，就像是类型别名决定了声明中结合的优先级一样。</p>
<h3 id="252-auto-类型说明符"><a class="markdownIt-Anchor" href="#252-auto-类型说明符"></a> 2.5.2 auto 类型说明符</h3>
<p>auto —般会忽略掉顶层 const 和引用，如果希望推断出的 auto 类型是一个顶层 const，需要明确指出。<br />
<code>const auto &amp;</code>是比较常见的写法。</p>
<h3 id="253-decltype-类型指示符"><a class="markdownIt-Anchor" href="#253-decltype-类型指示符"></a> 2.5.3 decltype 类型指示符</h3>
<p>decltype 会忽略指针。<br />
编译器分析表达式并得到它的类型，却不实际计算表达式的值。decltype 完整地保留参数的类型，包括 const 与引用。<br />
<strong>decltype 和引用</strong><br />
如果表达式的内容是解引用操作，则decltype将得到引用类型。如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。如果表达式的求值结果是左值，decltype 得到一个引用类引用型。因为变量是一种可以作为赋值语句左值的特殊表达式，所以这样的 decltype 就会得到引用类型。<br />
切记：<code>decltype((variaide))</code>的结果永远是引用类型。</p>
<h3 id="263-编写自己的头文件"><a class="markdownIt-Anchor" href="#263-编写自己的头文件"></a> 2.6.3 编写自己的头文件</h3>
<p>有必要在书写 头文件时做适当处理，使其遇到多次包含情况也能安全和正常地工作。<br />
<strong>预处理器概述</strong><br />
预处理器是在编译之前执行的一段程序。<br />
<strong>头文件保护符</strong><br />
头文件保护符依赖于预处理变量。<br />
<code>#define</code>指令把一个名字设定为预处理变量。<br />
<code>#ifdef</code>当且仅当变量已定义时为真。<br />
<code>#ifndef</code>当且仅当变量未定义时为真，一旦检查结果为真，则执行后续操作直至遇到<code>#endif</code>指令为止。<br />
整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> CLASS_NAME_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLASS_NAME_H</span><br><span class="hljs-comment">// 各种包含与定义。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<h1 id="第三章-字符串-向量和数组"><a class="markdownIt-Anchor" href="#第三章-字符串-向量和数组"></a> 第三章 字符串、向量和数组</h1>
<h2 id="32-标准库类型-string"><a class="markdownIt-Anchor" href="#32-标准库类型-string"></a> 3.2 标准库类型 string</h2>
<h3 id="321-定义和初始化-string-对象"><a class="markdownIt-Anchor" href="#321-定义和初始化-string-对象"></a> 3.2.1 定义和初始化 string 对象</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>)</span></span>; <span class="hljs-comment">// s 的内容是 cccccccccc</span><br>string s2 = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 拷贝初始化</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>; <span class="hljs-comment">// 直接初始化</span><br></code></pre></div></td></tr></table></figure>
<p><strong>读写 string 对象</strong><br />
string 对象会自动忽略开头的空白，直到遇见下一处空白为止。<br />
<strong>使用 getline 读取一整行</strong><br />
getline 函数的参数是一个输入流和一个 string 对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个 string 对象中去（注意不存换行符)。<br />
<strong>string::size_type 类型</strong><br />
size() 函数返回的是一个 string::size_type类型的值，它是一 个无符号类型的值（参见2.1.1节，第30页）而且能足够存放下任何string对象的大小。如果一条表达式中已经有了 size() 函数就不要再使用 int 了，这样可以避免<br />
混用 int 和 unsigned 可能带来的问题。</p>
<h2 id="33-标准库类型-vector"><a class="markdownIt-Anchor" href="#33-标准库类型-vector"></a> 3.3 标准库类型 vector</h2>
<p>因为引用不是对象，所以不存在包含引用的 vector。</p>
<h3 id="331-定义和初始化-vector-对象"><a class="markdownIt-Anchor" href="#331-定义和初始化-vector-对象"></a> 3.3.1 定义和初始化 vector 对象</h3>
<p><strong>值初始化</strong><br />
可以只提供 vector 对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由 vector 对象中元素的类型决定。如果 vector 对象的元素是内置类型，比如 int，则元素初始值自动设为 0。如果元素是某种类类型，比如 string，则元素由类默认初始化。<br />
如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造 vector 对象了。</p>
<h2 id="34-迭代器介绍"><a class="markdownIt-Anchor" href="#34-迭代器介绍"></a> 3.4 迭代器介绍</h2>
<h3 id="341-使用迭代器"><a class="markdownIt-Anchor" href="#341-使用迭代器"></a> 3.4.1 使用迭代器</h3>
<p><code>vector&lt;Type&gt;::iterator</code>与<code>vector&lt;Type&gt;::const_iterator</code>类型<br />
<strong>结合解引用与成员访问操作</strong><br />
<code>(*it).mem();</code>括号必不可少。为了简化上述表达式，C++ 语言定义了箭头运算符（-&gt;）。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，<code>it-&gt;mem</code>和<code>(*it) .mem</code>表达的意思相同。<br />
任何一种可能改变 vector 对象容量的操作，比如 push_back，都会使该 vector 对象的迭代器失效。<br />
两个迭代器相减所得结果的类型是名为 difference_type 的带符号整型数。</p>
<h2 id="35-数组"><a class="markdownIt-Anchor" href="#35-数组"></a> 3.5 数组</h2>
<p>数组的大小确定不变，维度必须是一个常量表达式，必须指定类型，不存在引用的数组，不允许拷贝和赋值。<br />
<strong>复杂的数组声明</strong><br />
<code>int *(&amp;arry)[10] = prts; // 首先arry是一个引用，引用对象为大小为10的数组，数组类型是指向int的指针</code></p>
<h3 id="353-指针和数组"><a class="markdownIt-Anchor" href="#353-指针和数组"></a> 3.5.3 指针和数组</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>; <span class="hljs-comment">// ia2是指向is第一个元素的指针</span><br><span class="hljs-keyword">decltype</span>(ia) ia3 = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// ia3是长度为5的整型数组</span><br></code></pre></div></td></tr></table></figure>
<p><strong>标准库函数 begin 和 end</strong><br />
begin() 函数返回指向数组首元素的指针，end() 函数返回指向数组尾元素下一位置的指针，这两个函数定义在 iterator 头文件中。<br />
<strong>指针运算</strong><br />
两个指针相减的结果的类型是一种名为 ptrdiff_t 的标准库类型，和 size_t —样，ptrdiff_t 也是一种定义在 cstddef 头文件中的机器相关的类型。因为差值可能为负值，所以 ptrdiff_t 是一种带符号类型。</p>
<h3 id="354-c-风格字符串"><a class="markdownIt-Anchor" href="#354-c-风格字符串"></a> 3.5.4 C 风格字符串</h3>
<p>string 类提供了 c_str() 函数，返回的是一个 C 风格字符串。<br />
允许使用数组来初始化 vector 对象。<br />
<code>vectro&lt;int&gt; ivec(begin(int_arr), end(int_arr));</code></p>
<h2 id="36-多维数组"><a class="markdownIt-Anchor" href="#36-多维数组"></a> 3.6 多维数组</h2>
<p><code>int ia[3][4] = &#123;&#123;0&#125;, &#123;1&#125;, &#123;3&#125;&#125;; // 显示地初始化每行的首元素</code><br />
要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型，否则 auto 的类型会是一个指针。</p>
<h1 id="第四章-表达式"><a class="markdownIt-Anchor" href="#第四章-表达式"></a> 第四章 表达式</h1>
<h2 id="41-基础"><a class="markdownIt-Anchor" href="#41-基础"></a> 4.1 基础</h2>
<h3 id="411-基本概念"><a class="markdownIt-Anchor" href="#411-基本概念"></a> 4.1.1 基本概念</h3>
<p><strong>运算对象转换</strong><br />
小整数类型（如 bool、char、short 等）通常会被提升成较大的整数类型，主要是 int。</p>
<h3 id="413-求值顺序"><a class="markdownIt-Anchor" href="#413-求值顺序"></a> 4.1.3 求值顺序</h3>
<p>编译器不会明确指定表达式中运算对象的求值顺序。<code>i++ + ++i</code>自然是未定义的操作。</p>
<h2 id="42-算术运算符"><a class="markdownIt-Anchor" href="#42-算术运算符"></a> 4.2 算术运算符</h2>
<p>m%(-n)=m%n; (-m)%n=-(m%n)</p>
<h2 id="44-赋值运算符"><a class="markdownIt-Anchor" href="#44-赋值运算符"></a> 4.4 赋值运算符</h2>
<p>右侧运算对象将转换成左侧运算对象的类型，赋值运算返回的是其左侧运算对象。<br />
复合运算符只求值一次。</p>
<h2 id="45-递增和递减运算符"><a class="markdownIt-Anchor" href="#45-递增和递减运算符"></a> 4.5 递增和递减运算符</h2>
<p>前置版本将更新后的对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。除非必须，否则不用递增递减运算符的后置版本。</p>
<h2 id="47-条件运算符"><a class="markdownIt-Anchor" href="#47-条件运算符"></a> 4.7 条件运算符</h2>
<p>条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通 常需要在它两端加上括号。</p>
<h2 id="48-位运算符"><a class="markdownIt-Anchor" href="#48-位运算符"></a> 4.8 位运算符</h2>
<p>如果运算对象是带符号的且它的值为负，那么位运算符如何处理运算对象的“符号位”依赖于机器。而且, 此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。<br />
左移运算符（&lt;&lt;）在右侧插入值为 0 的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为 0 的二进制位: 如果该运算对象是带符号类型，在左侧插入符号位的副本或值为 0 的二进制位。</p>
<h2 id="411-类型转换"><a class="markdownIt-Anchor" href="#411-类型转换"></a> 4.11 类型转换</h2>
<h3 id="4111-算术转换"><a class="markdownIt-Anchor" href="#4111-算术转换"></a> 4.11.1 算术转换</h3>
<p>算数表达式中运算符的运算对象将转换成最宽的类型。<br />
带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。</p>
<h3 id="4112-其他隐式类型转换"><a class="markdownIt-Anchor" href="#4112-其他隐式类型转换"></a> 4.11.2 其他隐式类型转换</h3>
<p>包括常量整数值 0 或者字面值 nullptr 能转换成任意指针类型。指向任意非常量的指针能转换成 void*。指向任意对象的指针能转换成 const void*。</p>
<h3 id="4113-显示转换"><a class="markdownIt-Anchor" href="#4113-显示转换"></a> 4.11.3 显示转换</h3>
<p><strong>static_cast</strong><br />
任何具有明确定义的类型转换，只要不包含底层 const，都可以使用 static_cast。<br />
<strong>const_cast</strong><br />
const_cast只能改变运算对象的底层 const。<br />
<strong>reinterpret_cast</strong><br />
通常为运算对象的位模式提供较低层次上的重新解释。reinterpret_cast 本质上依赖于机器且非常危险。<br />
<strong>旧式的强制转换</strong><br />
<code>type(exper)</code>或<code>(type)exper</code><br />
如果替换为 static_cast 或 const_cast 也合法，则执行与他们相似的行为，否则执行与 reinterpret_cast 相似的行为。</p>
<h1 id="第五章-语句"><a class="markdownIt-Anchor" href="#第五章-语句"></a> 第五章 语句</h1>
<h2 id="56-try-语句和异常处理"><a class="markdownIt-Anchor" href="#56-try-语句和异常处理"></a> 5.6 try 语句和异常处理</h2>
<p>抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。<br />
在 try 中 throw 异常，然后层层查找符合的 catch。如果最终还是没能找到任何匹配的catch子句，程序转到名为 terminate 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。</p>
<h1 id="第六章-函数"><a class="markdownIt-Anchor" href="#第六章-函数"></a> 第六章 函数</h1>
<h2 id="61-函数基础"><a class="markdownIt-Anchor" href="#61-函数基础"></a> 6.1 函数基础</h2>
<p><strong>形参和实参</strong><br />
实参是形参的初始值。编译器能以任意可行的顺序对实参求值。</p>
<h3 id="611-局部对象"><a class="markdownIt-Anchor" href="#611-局部对象"></a> 6.1.1 局部对象</h3>
<p><strong>自动对象</strong><br />
我们把只存在于块执行期间的对象称为自动对象。<br />
<strong>局部静态对象</strong><br />
局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。<br />
如果局部静态变量没有显式的初始值，它将执行值初始化。</p>
<h2 id="62-参数传递"><a class="markdownIt-Anchor" href="#62-参数传递"></a> 6.2 参数传递</h2>
<h3 id="623-const-形参和实参"><a class="markdownIt-Anchor" href="#623-const-形参和实参"></a> 6.2.3 const 形参和实参</h3>
<p>当用实参初始化形参时会忽略掉顶层 const。换句话说，形参的顶层 const 被忽略掉了。<br />
<strong>尽量使用常量引用</strong><br />
一个非常量引用的形参无法接受一个常量的实参</p>
<h3 id="624-数组形参"><a class="markdownIt-Anchor" href="#624-数组形参"></a> 6.2.4 数组形参</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[])</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>])</span></span>;<br><span class="hljs-comment">// 这三个函数是等价的。</span><br></code></pre></div></td></tr></table></figure>
<p><strong>数组引用形参</strong><br />
形参是数组的引用，维度是类型的一部分。<br />
<code>void fun(int (&amp;arr)[10]);</code><br />
<strong>传递多维数组</strong><br />
数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略：<br />
<code>void fun(int (*mat)[10])</code></p>
<h3 id="626-含有可变形参的函数"><a class="markdownIt-Anchor" href="#626-含有可变形参的函数"></a> 6.2.6 含有可变形参的函数</h3>
<p><strong>initializer_list 形参</strong><br />
实参数量未知但是全部实参的类型都相同，initializer_list 也是一种模板类型，对象中的元素永远是常量值。如果想向 initializer_list 形参中传递一个值的序歹，则必须把序列放在一对花括号内：<br />
<code>fun(&#123;a, b, c&#125;);</code><br />
<strong>省略符形参</strong><br />
省略符形参只能出现在形参列表的最后一个位置，大多数类类型的对象在传递给省略符形参时都无法正确拷贝，省略符形参所对应的实参无须类型检查。<br />
<code>void fun(int a, ...)</code></p>
<h2 id="63-返回类型和-return-语句"><a class="markdownIt-Anchor" href="#63-返回类型和-return-语句"></a> 6.3 返回类型和 return 语句</h2>
<h3 id="631-无返回值函数"><a class="markdownIt-Anchor" href="#631-无返回值函数"></a> 6.3.1 无返回值函数</h3>
<p>在这类函数的最后一句后面会隐式地执行 return。一个返冋类型是 void 的函数也能返回另一个返回 void 的函数。</p>
<h3 id="632-有返回值函数"><a class="markdownIt-Anchor" href="#632-有返回值函数"></a> 6.3.2 有返回值函数</h3>
<p>返冋的值用于初始化调 用点的一个临时量，该临时量就是函数调用的结果。</p>
<h3 id="633-返回数组指针"><a class="markdownIt-Anchor" href="#633-返回数组指针"></a> 6.3.3 返回数组指针</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> arrT[<span class="hljs-number">10</span>]; <span class="hljs-comment">// arrT的类型是长度为10的int数组</span><br><span class="hljs-keyword">using</span> arrT = <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 等价</span><br></code></pre></div></td></tr></table></figure>
<p>返回数组指针的函数形如：<br />
<code>Type(*fun(par_list))[dim]</code><br />
<strong>使用尾置返回类型</strong><br />
尾置返冋类型跟在形参列表后面并以一个（-&gt;）符号开头。在本应该出现返回类型的地方放置一个 auto。<br />
<code>auto fun(int i) -&gt; int (*) [10];</code><br />
注意：decltype 并不负责把数组类型转换成对应的指针。</p>
<h2 id="64-函数重载"><a class="markdownIt-Anchor" href="#64-函数重载"></a> 6.4 函数重载</h2>
<p>一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参R分开来。</p>
<h2 id="65-特殊用途语言特性"><a class="markdownIt-Anchor" href="#65-特殊用途语言特性"></a> 6.5 特殊用途语言特性</h2>
<h3 id="651-默认实参"><a class="markdownIt-Anchor" href="#651-默认实参"></a> 6.5.1 默认实参</h3>
<p>为了使得窗口函数既能接纳默认值，也能接受用户指定的值，我们把它定义成如下的形式：<br />
<code>void fun(int a, int b = 0, int c = 1);</code><br />
一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值，默认实参负责填补函数调用缺少的尾部实参。<br />
用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时。</p>
<h3 id="652-内联函数和-constexpr-函数"><a class="markdownIt-Anchor" href="#652-内联函数和-constexpr-函数"></a> 6.5.2 内联函数和 constexpr 函数</h3>
<p><strong>内联函数可避免函数调用的开销</strong><br />
在函数的返回类型前面加上关键字 inline，内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。<br />
<strong>constexpr 函数</strong><br />
函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条 return 语句。<br />
编译器把对 constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr 函数被隐式地指定为内联函数。<br />
我们允许 constexpr 函数的返回值并非一个常量。</p>
<h3 id="653-调试帮助"><a class="markdownIt-Anchor" href="#653-调试帮助"></a> 6.5.3 调试帮助</h3>
<p><code>assert(expr);</code><br />
如果表达式为真（即非0），assert 什么也不做。assert 宏常用于检查“不能发生”的条件。<br />
<strong>NDEBUG 预处理变量</strong><br />
<code>#define NDEBUG</code><br />
如果定义了 NDEBUG, 则 assert 什么也不做。定义 NDEBUG 能避免检查各种条件所需的运行时开销。</p>
<h2 id="66-函数匹配"><a class="markdownIt-Anchor" href="#66-函数匹配"></a> 6.6 函数匹配</h2>
<p><strong>确定候选函数和可行函数</strong><br />
候选函数：一是与被调用的函数同名，二是其声明在调用点可见。<br />
可行函数：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。<br />
<strong>寻找最佳匹配</strong><br />
如果有且只有一个函数满足下列条件，则匹配成功：</p>
<ul>
<li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配。</li>
</ul>
<p>如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报 告二义性调用的信息。</p>
<h2 id="67-函数指针"><a class="markdownIt-Anchor" href="#67-函数指针"></a> 6.7 函数指针</h2>
<p><strong>使用函数指针</strong><br />
当我们把函数名作为一个值使用时，该函数自动地转换成指针（取地址符可选）<br />
我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针（解引用符可选）<br />
在指向不同函数类型的指针间不存在转换规则。<br />
<strong>函数指针形参</strong><br />
形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fun2())</span></span>; <span class="hljs-comment">// 形参是函数类型，它会自动地转换成指向函数的指针。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*fun2)())</span></span>; <span class="hljs-comment">// 显式地将形参定义成指向函数的指针。</span><br></code></pre></div></td></tr></table></figure>
<p>直接把函数作为实参使用，此时它会自动转换成指针。<br />
<code>fun1(fun);</code><br />
<strong>返回指向函数的指针</strong><br />
编译器不会自动地将函数返回类型当成对应的指针类型处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> F = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>();<br><span class="hljs-keyword">using</span> PF = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*)();<br><br><span class="hljs-function">PF <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// PF是指向函数的指针，fl返回指向函数的指针。</span><br><span class="hljs-function">F *<span class="hljs-title">fi</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 显式地指定返回类型是指向函数的指针。</span><br></code></pre></div></td></tr></table></figure>
<h1 id="第七章-类"><a class="markdownIt-Anchor" href="#第七章-类"></a> 第七章 类</h1>
<h2 id="71-定义抽象数据类型"><a class="markdownIt-Anchor" href="#71-定义抽象数据类型"></a> 7.1 定义抽象数据类型</h2>
<p><strong>引入 this</strong><br />
<code>total.isbn()</code><br />
当 isbn() 返冋 bookNo 时，实际上它隐式地返回 total.bookNo。<br />
编译器负责把 total 的地址传递给 isbn() 的隐式形参 this，任何对类成员的直接访问都被看作this的隐式引用。<br />
因为 this 的目的总是指向“这个”对象，所以 this 是一个常量指针。<br />
<strong>引入 const 成员函数</strong><br />
默认情况下，this 的类型是指向类类型非常量版本的常量指针。由于底层 const 不匹配，我们不能在一个常量对象上调用普通的成员函数。<br />
紧跟在参数列表后面的 const 表示 this 是一个指向常量的指针，常量成员函数不能改变调用它的对象的内容。常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p>
<h3 id="714-构造函数"><a class="markdownIt-Anchor" href="#714-构造函数"></a> 7.1.4 构造函数</h3>
<p>构造函数不能被声明成 const 的，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在 const 对象的构造过程中可以向其写值。</p>
<h3 id="721-友元"><a class="markdownIt-Anchor" href="#721-友元"></a> 7.2.1 友元</h3>
<p>友元声明只能出现在类定义的内部，友元不是类的成员也不受它所在区域访问控制级别的约束。<br />
<strong>友元的声明</strong><br />
友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。</p>
<h2 id="73-类的其他特性"><a class="markdownIt-Anchor" href="#73-类的其他特性"></a> 7.3 类的其他特性</h2>
<h3 id="731-类成员再探"><a class="markdownIt-Anchor" href="#731-类成员再探"></a> 7.3.1 类成员再探</h3>
<p><strong>定义_个类型成员</strong><br />
类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> pos = std::string::size_type;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>定义在类内部的成员函数是自动 inline 的。<br />
<strong>可变数据成员</strong><br />
在变量的声明中加入 mutable 关键字，一个可变数据成员永远不会是 const，即使它是 const 对象的成员。因此，一个 const 成员函数可以改变一个可变成员的值。</p>
<h3 id="732-返回-this-的成员函数"><a class="markdownIt-Anchor" href="#732-返回-this-的成员函数"></a> 7.3.2 返回 *this 的成员函数</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ClassName &amp;<span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>返回引用的函数是左值的，所以这样的操作将在同一个对象上执行：<br />
<code>实例.fun1().fun2().fun3()</code><br />
如果定义的返回类型不是引用，则函数的返回值将是 *this 的副本，因此调用函数只能改变临时副本，而不能改变原实例的值。<br />
*<em>从 const 成员函数返回 <em>this</em></em><br />
一个 const 成员函数如果以引用的形式返回 *this，那么它的返回类里将是常量引用，因为非常量版本的函数对于常量对象是不可用的。<br />
根据对象是否是常量重载函数，隐式传入的 this 参数同样参与函数匹配的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ClassName &amp;<span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> ClassName &amp;<span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="733-类类型"><a class="markdownIt-Anchor" href="#733-类类型"></a> 7.3.3 类类型</h3>
<p>在类声明之后定义之前是一个不完全类型，可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。一旦一个类的名字出现后，它就被认为是声明过了。</p>
<h3 id="734-友元再探"><a class="markdownIt-Anchor" href="#734-友元再探"></a> 7.3.4 友元再探</h3>
<p>友元关系不存在传递性。<br />
友元类的成员函数和友元成员函数可以访问此类包括非公有成员在内的所有成员。<br />
如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。<br />
<strong>友元声明和作用域</strong><br />
当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-built_in">ClassName</span>() &#123;<br>        <span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// 错误</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ClassName::a</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// 错误</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ClassName::b</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// 正确</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="74-类的作用域"><a class="markdownIt-Anchor" href="#74-类的作用域"></a> 7.4 类的作用域</h2>
<p>在类的外部定义其成员函数时，因为返回类型出现在类名之前，所以事实上返回类型是位于类的作用域之外的。<br />
<strong>类作用域之后，在外围的作用域中查找</strong><br />
如果我们需要的是外层作用域中的名字，可以显式地通过作用域运算符（::）来进行请求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span> * ::tmp; <span class="hljs-comment">// 此时的in是最外层的全局变量</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="75-构造函数再探"><a class="markdownIt-Anchor" href="#75-构造函数再探"></a> 7.5 构造函数再探</h2>
<h3 id="751-构造函数初姶值列表"><a class="markdownIt-Anchor" href="#751-构造函数初姶值列表"></a> 7.5.1 构造函数初姶值列表</h3>
<p>如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。<br />
如果成员是 const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。<br />
成员的初始化顺序与它们在类定义中的出现顺序一致，构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。<br />
如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。</p>
<h3 id="754-隐式的类类型转换"><a class="markdownIt-Anchor" href="#754-隐式的类类型转换"></a> 7.5.4 隐式的类类型转换</h3>
<p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制（转换构造函数）。在需要使用类类型的地方，我们可以使用转换构造函数的参数的类型作为替代。<br />
只允许一步类类型转换，隐式地使用两种转换规则是错误的。比如只定义了 string 的转换构造函数却提供了一个字符串常量实参。<br />
<strong>抑制构造函数定义的隐式转换</strong><br />
将构造函数声明为 explicit 加以抑制隐式转换。<br />
关键字 explicit 只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换。只能在类内声明构造函数时使用 explicit 关键字，在类外部定义时不应重复。<br />
显示地进行强制转换依旧可以正常地发挥转换构造函数的效果。</p>
<h3 id="755-聚合类"><a class="markdownIt-Anchor" href="#755-聚合类"></a> 7.5.5 聚合类</h3>
<p>当一个类满足如下条件时，我们说它是聚合的：</p>
<ul>
<li>所有成员都是 public 的。</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值。</li>
<li>没有基类，也没有 virtual 函数。<br />
可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员，初始值的顺序必须与声明的顺序一致。</li>
</ul>
<h3 id="756-字面值常量类"><a class="markdownIt-Anchor" href="#756-字面值常量类"></a> 7.5.6 字面值常量类</h3>
<p>数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：</p>
<ul>
<li>数据成员都必须是字面值类型。</li>
<li>类必须至少含有一个 constexpr 构造函数。</li>
<li>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的 constexpr 构造函数。</li>
<li>类必须使用析构函数的默认定义，该成员负责销毁类的对象。<br />
<strong>constexpr 构造函数</strong><br />
尽管构造函数不能是 const 的，但是字面值常量类的构造函数可以是 constexpr 函数，constexpr 构造函数体一般来说应该是空的，或者声明成<code>= default</code>.<br />
constexpr 构造函数必须初始化所有数据成员.</li>
</ul>
<h2 id="76-类的静态成员"><a class="markdownIt-Anchor" href="#76-类的静态成员"></a> 7.6 类的静态成员</h2>
<p>对象中不包含任何与静态数据成员有关的数据，静态成员函数不能声明成 const 的，而且我们也不能在 static 函数体内使用 this 指针。<br />
使用作用域运算符直接访问静态成员，使用类的对象、引用或者指针的点运算符来访问静态成员。<br />
<strong>定义静态成员</strong><br />
当在类的外部定义静态成员时，不能重复 static 关键字，该关键字只出现在类内部的声明语句。<br />
我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。<br />
<strong>静态成员的类内初始化</strong><br />
我们可以为静态成员提供 const 整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的 constexpr。即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外<br />
部定义一下该成员。<br />
静态数据成员可以是不完全类型。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/CPP/">CPP</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/15/CppPrimer8-12/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">笔记 C++ Primer 第八章~第十二章</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/08/SimpleRenderer/">
                        <span class="hidden-mobile">Simple Renderer</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"5e2153d92606f0f30050","clientSecret":"71138048e7eacddcadcf14ce72f87fe12fa35c40","repo":"Hinageshi01.github.io","owner":"Hinageshi01","admin":["Hinageshi01"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '6ae3868f7fea00fa57f15b02453109e5'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <br/> 本站内容依据 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> 许可证进行授权 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.css" />
  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
